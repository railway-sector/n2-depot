"use strict";(self.webpackChunkn2_depot=self.webpackChunkn2_depot||[]).push([[7177],{29234:(e,t,i)=>{i.d(t,{A:()=>h});var n,a=i(81806),r=i(97255),s=i(3789);const o=4294967296,l=new TextDecoder("utf-8"),c=(0,a.A)("safari")||(0,a.A)("ios")?6:(0,a.A)("ff")?12:32;class h{constructor(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e?e.byteLength:0;this._tag=0,this._dataType=99,this._init(e,t,i,n)}_init(e,t,i,n){this._data=e,this._dataView=t,this._pos=i,this._end=n}get usedMemory(){return 64+(0,r.Qf)(this._data)}asUnsafe(){return this}clone(){return new h(this._data,this._dataView,this._pos,this._end)}pos(){return this._pos}move(e){this._pos=e}nextTag(e){for(;;){if(this._pos===this._end)return!1;const t=this._decodeVarint();if(this._tag=t>>3,this._dataType=7&t,!e||e===this._tag)break;this.skip()}return!0}next(){if(this._pos===this._end)return!1;const e=this._decodeVarint();return this._tag=e>>3,this._dataType=7&e,!0}empty(){return this._pos>=this._end}tag(){return this._tag}getInt32(){return this._decodeVarint()}getInt64(){return this._decodeVarint()}getUInt32(){let e=4294967295;if(e=(127&this._data[this._pos])>>>0,this._data[this._pos++]<128)return e;if(e=(e|(127&this._data[this._pos])<<7)>>>0,this._data[this._pos++]<128)return e;if(e=(e|(127&this._data[this._pos])<<14)>>>0,this._data[this._pos++]<128)return e;if(e=(e|(127&this._data[this._pos])<<21)>>>0,this._data[this._pos++]<128)return e;if(e=(e|(15&this._data[this._pos])<<28)>>>0,this._data[this._pos++]<128)return e;throw new Error("Varint overflow")}getUInt64(){return this._decodeVarint()}getSInt32(){const e=this.getUInt32();return e>>>1^-(1&e)}getSInt64(){return this._decodeSVarint()}getBool(){const e=0!==this._data[this._pos];return this._skip(1),e}getEnum(){return this._decodeVarint()}getFixed64(){const e=this._dataView,t=this._pos,i=e.getUint32(t,!0)+e.getUint32(t+4,!0)*o;return this._skip(8),i}getSFixed64(){const e=this._dataView,t=this._pos,i=e.getUint32(t,!0)+e.getInt32(t+4,!0)*o;return this._skip(8),i}getDouble(){const e=this._dataView.getFloat64(this._pos,!0);return this._skip(8),e}getFixed32(){const e=this._dataView.getUint32(this._pos,!0);return this._skip(4),e}getSFixed32(){const e=this._dataView.getInt32(this._pos,!0);return this._skip(4),e}getFloat(){const e=this._dataView.getFloat32(this._pos,!0);return this._skip(4),e}getString(){const e=this._getLength(),t=this._pos,i=this._toString(this._data,t,t+e);return this._skip(e),i}getBytes(){const e=this._getLength(),t=this._pos,i=this._toBytes(this._data,t,t+e);return this._skip(e),i}getLength(){return this._getLengthUnsafe()}processMessageWithArgs(e,t,i,n){const a=this.getMessage(),r=e(a,t,i,n);return a.release(),r}processMessage(e){const t=this.getMessage(),i=e(t);return t.release(),i}getMessage(){const e=this._getLength(),t=h.pool.acquire();return t._init(this._data,this._dataView,this._pos,this._pos+e),this._skip(e),t}release(){h.pool.release(this)}dataType(){return this._dataType}skip(){switch(this._dataType){case 0:this._decodeVarint();break;case 1:this._skip(8);break;case 2:this._skip(this._getLength());break;case 5:this._skip(4);break;default:throw new Error("Invalid data type!")}}skipLen(e){this._skip(e)}_skip(e){if(this._pos+e>this._end)throw new Error("Attempt to skip past the end of buffer!");this._pos+=e}_decodeVarint(){const e=this._data;let t=this._pos,i=0,n=0;if(this._end-t>=10)do{if(n=e[t++],i|=127&n,!(128&n))break;if(n=e[t++],i|=(127&n)<<7,!(128&n))break;if(n=e[t++],i|=(127&n)<<14,!(128&n))break;if(n=e[t++],i|=(127&n)<<21,!(128&n))break;if(n=e[t++],i+=268435456*(127&n),!(128&n))break;if(n=e[t++],i+=34359738368*(127&n),!(128&n))break;if(n=e[t++],i+=4398046511104*(127&n),!(128&n))break;if(n=e[t++],i+=562949953421312*(127&n),!(128&n))break;if(n=e[t++],i+=72057594037927940*(127&n),!(128&n))break;if(n=e[t++],i+=0x8000000000000000*(127&n),!(128&n))break;throw new Error("Varint too long!")}while(0);else{let a=1;for(;t!==this._end&&(n=e[t],128&n);)++t,i+=(127&n)*a,a*=128;if(t===this._end)throw new Error("Varint overrun!");++t,i+=n*a}return this._pos=t,i}_decodeSVarint(){const e=this._data;let t,i=0,n=0;const a=1&e[this._pos];if(n=e[this._pos++],i|=127&n,!(128&n))return a?-(i+1)/2:i/2;if(n=e[this._pos++],i|=(127&n)<<7,!(128&n))return a?-(i+1)/2:i/2;if(n=e[this._pos++],i|=(127&n)<<14,!(128&n))return a?-(i+1)/2:i/2;if(n=e[this._pos++],i|=(127&n)<<21,!(128&n))return a?-(i+1)/2:i/2;if(n=e[this._pos++],i+=268435456*(127&n),!(128&n))return a?-(i+1)/2:i/2;if(n=e[this._pos++],i+=34359738368*(127&n),!(128&n))return a?-(i+1)/2:i/2;if(n=e[this._pos++],i+=4398046511104*(127&n),!(128&n))return a?-(i+1)/2:i/2;if(t=BigInt(i),n=e[this._pos++],t+=0x2000000000000n*BigInt(127&n),!(128&n))return Number(a?-(t+1n)/2n:t/2n);if(n=e[this._pos++],t+=0x100000000000000n*BigInt(127&n),!(128&n))return Number(a?-(t+1n)/2n:t/2n);if(n=e[this._pos++],t+=0x8000000000000000n*BigInt(127&n),!(128&n))return Number(a?-(t+1n)/2n:t/2n);throw new Error("Varint too long!")}_getLength(){if(2!==this._dataType)throw new Error("Not a delimited data type!");return this._decodeVarint()}_getLengthUnsafe(){return this.getUInt32()}_toString(e,t,i){if((i=Math.min(this._end,i))-t>c){const n=e.subarray(t,i);return l.decode(n)}let n="",a="";for(let r=t;r<i;++r){const t=e[r];128&t?a+="%"+t.toString(16):(n+=decodeURIComponent(a)+String.fromCharCode(t),a="")}return a.length&&(n+=decodeURIComponent(a)),n}_toBytes(e,t,i){return i=Math.min(this._end,i),new Uint8Array(e.buffer,t,i-t)}}(n=h).pool=new s.A(()=>new n(null,null),void 0,e=>{e._data=null,e._dataView=null})},47177:(e,t,i)=>{i.r(t),i.d(t,{default:()=>Ce});var n=i(6326),a=i(50076),r=i(81806),s=i(30726),o=i(50346),l=i(68134),c=i(46053),h=(i(76460),i(47249),i(87990));class u{constructor(e,t,i){this._scale=e,this._shift=t,this._levelShift=i}getLevelRowColumn(e){const t=this.getLevelShift(e[0]),i=this._shift+t;return i?[e[0]-t,e[1]>>i,e[2]>>i]:e}getLevelShift(e){return Math.min(e,this._levelShift)}getOffset(e,t){let i=0,n=0;const a=this._shift+this.getLevelShift(e[0]);if(a){const r=(1<<a)-1,s=t/(this._scale*(1<<a-1));i=(e[2]&r)*s,n=(e[1]&r)*s}return[i,n]}getScale(e){return this._scale*(1<<this._shift+this.getLevelShift(e))}}var d=i(79369),p=i(85827),_=i(2413),f=i(9377),g=i(89379),m=i(90534),v=i(16783),y=i(15671);class w{constructor(e,t){this._width=0,this._height=0,this._free=[],this._width=e,this._height=t,this._free.push(new y.A(0,0,e,t))}get width(){return this._width}get height(){return this._height}allocate(e,t){if(e>this._width||t>this._height)return new y.A;let i=null,n=-1;for(let a=0;a<this._free.length;++a){const r=this._free[a];e<=r.width&&t<=r.height&&(null===i||r.y<=i.y&&r.x<=i.x)&&(i=r,n=a)}return null===i?new y.A:(this._free.splice(n,1),i.width<i.height?(i.width>e&&this._free.push(new y.A(i.x+e,i.y,i.width-e,t)),i.height>t&&this._free.push(new y.A(i.x,i.y+t,i.width,i.height-t))):(i.width>e&&this._free.push(new y.A(i.x+e,i.y,i.width-e,i.height)),i.height>t&&this._free.push(new y.A(i.x,i.y+t,e,i.height-t))),new y.A(i.x,i.y,e,t))}release(e){for(let t=0;t<this._free.length;++t){const i=this._free[t];if(i.y===e.y&&i.height===e.height&&i.x+i.width===e.x)i.width+=e.width;else if(i.x===e.x&&i.width===e.width&&i.y+i.height===e.y)i.height+=e.height;else if(e.y===i.y&&e.height===i.height&&e.x+e.width===i.x)i.x=e.x,i.width+=e.width;else{if(e.x!==i.x||e.width!==i.width||e.y+e.height!==i.y)continue;i.y=e.y,i.height+=e.height}this._free.splice(t,1),this.release(e)}this._free.push(e)}}var x=i(98433),S=i(96673);class b{constructor(e,t,i){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=e,this.height=t,this._glyphSource=i,this._binPack=new w(e-4,t-4),this._glyphData.push(new Uint8Array(e*t)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(e,t){const i=[],n=this._glyphSource,a=new Set,r=1/256;for(const o of t){const e=Math.floor(o*r);a.add(e)}const s=[];return a.forEach(t=>{const i=e+t;if(this._rangePromises.has(i))s.push(this._rangePromises.get(i));else{const a=n.getRange(e,t).then(()=>{this._rangePromises.delete(i)},()=>{this._rangePromises.delete(i)});this._rangePromises.set(i,a),s.push(a)}}),Promise.all(s).then(()=>{let a=this._glyphIndex[e];a||(a={},this._glyphIndex[e]=a);for(const r of t){const t=a[r];if(t){i[r]={sdf:!0,rect:t.rect,metrics:t.metrics,page:t.page,code:r};continue}const s=n.getGlyph(e,r);if(null===s||void 0===s||!s.metrics)continue;const o=s.metrics;let l;if(0===o.width)l=new y.A(0,0,0,0);else{const e=3,t=o.width+2*e,i=o.height+2*e;let n=t%4?4-t%4:4,a=i%4?4-i%4:4;1===n&&(n=5),1===a&&(a=5),l=this._binPack.allocate(t+n,i+a),l.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new w(this.width-4,this.height-4),l=this._binPack.allocate(t+n,i+a));const r=this._glyphData[this._currentPage],c=s.bitmap;let h,u;if(c)for(let s=0;s<i;s++){h=t*s,u=this.width*(l.y+s+1)+l.x;for(let e=0;e<t;e++)r[u+e+1]=c.at(h+e)}}a[r]={rect:l,metrics:o,tileIDs:null,page:this._currentPage},i[r]={sdf:!0,rect:l,metrics:o,page:this._currentPage,code:r},this._dirties[this._currentPage]=!0}return i})}removeGlyphs(e){for(const t in this._glyphIndex){const i=this._glyphIndex[t];if(!i)continue;let n;for(const t in i)if(n=i[t],n.tileIDs.delete(e),0===n.tileIDs.size){const e=this._glyphData[n.page],a=n.rect;let r,s;for(let t=0;t<a.height;t++)for(r=this.width*(a.y+t)+a.x,s=0;s<a.width;s++)e[r+s]=0;delete i[t],this._dirties[n.page]=!0}}}bind(e,t,i){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(!this._textures[i]){const t=new S.R(this.width,this.height);t.pixelFormat=6406,t.wrapMode=33071,this._textures[i]=new x.g(e,t,new Uint8Array(this.width*this.height))}const a=this._textures[i];a.setSamplingMode(t),this._dirties[i]&&a.setData(this._glyphData[i]),e.bindTexture(a,n),this._dirties[i]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const e of this._textures)e&&e.dispose();this._textures.length=0}}var M=i(3825),P=i(29234);class C{constructor(e){if(this._metrics=[],!e)return void(this._allBitmaps=null);const t=new Map;let i=0;for(;e.next();)switch(e.tag()){case 1:{const r=e.getMessage();for(;r.next();)switch(r.tag()){case 3:{const e=r.getMessage();let s,o,l,c,h,u,d;for(;e.next();)switch(e.tag()){case 1:s=e.getUInt32();break;case 2:o=e.getBytes();break;case 3:l=e.getUInt32();break;case 4:c=e.getUInt32();break;case 5:h=e.getSInt32();break;case 6:u=e.getSInt32();break;case 7:d=e.getUInt32();break;default:e.skip()}if(e.release(),s){var n,a;const e=null!==(n=null===(a=o)||void 0===a?void 0:a.length)&&void 0!==n?n:0;this._metrics[s]={width:l,height:c,left:h,top:u,advance:d,startOffset:i,length:e},t.set(s,o),i+=e}break}default:r.skip()}r.release();break}default:e.skip()}const r=new Uint8Array(i),s=this._metrics;for(const[o,l]of t){const{startOffset:e,length:t}=s[o];if(l)for(let i=0;i<t;++i)r[e+i]=l[i]}this._allBitmaps=r}getMetrics(e){return this._metrics[e]}getBitmap(e){if(!this._allBitmaps)return;const t=this._metrics[e];if(void 0===t)return;const{startOffset:i,length:n}=t;return 0!==n?new I(this._allBitmaps,i,n):void 0}}class T{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(e){return this._ranges[e]}addRange(e,t){this._ranges[e]=t}}class R{constructor(e){this._glyphInfo={},this._baseURL=e}getRange(e,t){const i=this._getFontStack(e);if(i.getRange(t))return Promise.resolve();const n=256*t,a=n+255;if(this._baseURL){const r=this._baseURL.replace("{fontstack}",e).replace("{range}",n+"-"+a);return(0,M.A)(r,{responseType:"array-buffer"}).then(e=>{i.addRange(t,new C(new P.A(new Uint8Array(e.data),new DataView(e.data))))}).catch(()=>{i.addRange(t,new C)})}return i.addRange(t,new C),Promise.resolve()}getGlyph(e,t){const i=this._getFontStack(e);if(!i)return;const n=Math.floor(t/256),a=i.getRange(n);return a?{metrics:a.getMetrics(t),bitmap:a.getBitmap(t)}:void 0}_getFontStack(e){let t=this._glyphInfo[e];return t||(t=this._glyphInfo[e]=new T),t}}class I{constructor(e,t,i){this._array=e,this._start=t,this.length=i}at(e){return 0<=e&&e<this.length?this._array[this._start+e]:void 0}}var D=i(83367);class E{constructor(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,t<=0&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=t,i>0&&(this._maxItemSize=i),this._binPack=new w(e-4,t-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new w(this._pageWidth-4,this._pageHeight-4);const e=Math.floor(this._pageWidth),t=Math.floor(this._pageHeight),i=new Uint32Array(e*t);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e){var t,i;let n,a,r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],s=this._mosaicRects[e];if(s)return s;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;if(e&&e.startsWith("dasharray-")?([n,a]=this._rasterizeDash(e),r=!0):n=this._sprites.getSpriteInfo(e),null===(t=n)||void 0===t||!t.width||!n.height||n.width<0||n.height<0)return null;const o=n.width,l=n.height,[c,h,u]=this._allocateImage(o,l);return c.width<=0?null:(this._copy(c,n,h,u,r,a),s={type:"sprite",rect:c,width:o,height:l,sdf:n.sdf,simplePattern:!1,rasterizationScale:null!==(i=n.pixelRatio)&&void 0!==i?i:1,samplingMode:"Linear",page:h},this._mosaicRects[e]=s,s)}getSpriteItems(e){const t={};for(const i of e)t[i.name]=this.getSpriteItem(i.name,i.repeat);return t}getMosaicItemPosition(e,t){const i=this.getSpriteItem(e,t),n=null===i||void 0===i?void 0:i.rect;if(!n)return null;n.width=i.width,n.height=i.height;const a=i.width,r=i.height;return{tl:[n.x+2,n.y+2],br:[n.x+2+a,n.y+2+r],page:i.page}}bind(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(i>=this._size.length||i>=this._mosaicsData.length)return;if(!this._textures[i]){const t=new S.R(this._size[i][0],this._size[i][1]);t.wrapMode=33071,this._textures[i]=new x.g(e,t,new Uint8Array(this._mosaicsData[i].buffer))}const a=this._textures[i];a.setSamplingMode(t),this._dirties[i]&&a.setData(new Uint8Array(this._mosaicsData[i].buffer)),e.bindTexture(a,n),this._dirties[i]=!1}static _copyBits(e,t,i,n,a,r,s,o,l,c,h){let u=n*t+i,d=o*r+s;if(h){d-=r;for(let s=-1;s<=c;s++,u=((s+c)%c+n)*t+i,d+=r)for(let t=-1;t<=l;t++)a[d+t]=e[u+(t+l)%l]}else for(let p=0;p<c;p++){for(let t=0;t<l;t++)a[d+t]=e[u+t];u+=t,d+=r}}_copy(e,t,i,n,a,r){if(!this._sprites||"loaded"!==this._sprites.loadStatus||i>=this._mosaicsData.length)return;const s=new Uint32Array(r?r.buffer:this._sprites.image.buffer),o=this._mosaicsData[i],l=r?t.width:this._sprites.width;E._copyBits(s,l,t.x,t.y,o,n[0],e.x+2,e.y+2,t.width,t.height,a),this._dirties[i]=!0}_allocateImage(e,t){e+=2,t+=2;const i=Math.max(e,t);if(this._maxItemSize&&this._maxItemSize<i){const i=new y.A(0,0,e,t);return this._mosaicsData.push(new Uint32Array(e*t)),this._dirties.push(!0),this._size.push([e,t]),this._textures.push(void 0),[i,this._mosaicsData.length-1,[e,t]]}let n=e%4?4-e%4:4,a=t%4?4-t%4:4;1===n&&(n=5),1===a&&(a=5);const r=this._binPack.allocate(e+n,t+a);return r.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new w(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,t)):[r,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const t=e.match(/\[(.*?)\]/);if(!t)return null;const i=t[1].split(",").map(Number),n=e.slice(e.lastIndexOf("-")+1),[a,r,s]=(0,D.k2)(i,n);return[{x:0,y:0,width:r,height:s,sdf:!0,pixelRatio:1},new Uint8Array(a.buffer)]}}var L=i(93453);class A{constructor(e,t,i,n){this._layer=e,this._styleRepository=t,this.devicePixelRatio=i,this._sourceDataMaxLOD=n,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){var e,t,i;null!==(e=this._connection)&&void 0!==e&&e.close(),this._connection=null,this._styleRepository=null,this._layer=null,null!==(t=this._spriteMosaic)&&void 0!==t&&t.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=(0,s.DC)(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&null!==(i=this._startOptionsInputSignal)&&void 0!==i&&i.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(e){this._requestSprite(e);const t=this._layer.currentStyleInfo.glyphsUrl,i=new R(t?(0,m.a6)(t,(0,g.A)((0,g.A)({},this._layer.customParameters),{},{token:this._layer.apiKey})):null);this._glyphMosaic=new b(1024,1024,i),this._broadcastPromise=(0,v.ho)("WorkerTileHandler",{client:this,schedule:e.schedule,signal:e.signal}).then(t=>{var i;if(this._layer&&(null!==(i=this._connection)&&void 0!==i&&i.close(),this._connection=t,this._layer&&!this._connection.closed)){const i=t.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},e);Promise.all(i).catch(e=>(0,o.jH)(e))}})}_requestSprite(e){var t,i;null===(t=this._spriteSourceAbortController)||void 0===t||t.abort();const n=new AbortController;this._spriteSourceAbortController=n;const a=null===e||void 0===e?void 0:e.signal;this._inputSignalEventListener&&null!==(i=this._startOptionsInputSignal)&&void 0!==i&&i.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,a&&(this._inputSignalEventListener=function(e){return()=>e.abort()}(n),a.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:r}=n,s=(0,g.A)((0,g.A)({},e),{},{signal:r});this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,s),this._spriteSourcePromise.then(e=>{(0,o.QP)(r),this._spriteMosaic=new E(1024,1024,250),this._spriteMosaic.setSpriteSource(e)})}async updateStyle(e){const t=[];for(const i of e)4===i.type?t.push({type:4,data:{spriteSource:null}}):t.push(i);return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",t)),this._broadcastPromise}setSpriteSource(e){const t=new E(1024,1024,250);return t.setSpriteSource(e),this._spriteMosaic=t,this._spriteSourcePromise=Promise.resolve(e),this._spriteSourceAbortController=null,t}async setStyle(e,t,i){await this._broadcastPromise,this._styleRepository=e,this._sourceDataMaxLOD=i,this._requestSprite();const n=new R(this._layer.currentStyleInfo.glyphsUrl?(0,m.a6)(this._layer.currentStyleInfo.glyphsUrl,(0,g.A)((0,g.A)({},this._layer.customParameters),{},{token:this._layer.apiKey})):null);return this._glyphMosaic=new b(1024,1024,n),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:t,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(e,t){const i=await this._getRefKeys(e,t);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),i,t)}async fetchTilePBFs(e){const t=Object.keys(this._layer.sourceNameToSource),i={},n=await this._getRefKeys(e,i),a=[],r=[];for(let s=0;s<n.length;s++)if(null==n[s].value||null==t[s])r.push(null);else{const e=n[s].value,o=this._getTilePayload(e,t[s],i);o.then(t=>{a.push((0,g.A)((0,g.A)({},t),{},{key:e}))}),r.push(o)}return Promise.all(r).then(()=>a)}async parseTileData(e,t){const i=e&&e.data;if(!i)return null;const{sourceName2DataAndRefKey:n,transferList:a}=i;return 0===Object.keys(n).length?null:this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:n,styleLayerUIDs:e.styleLayerUIDs},(0,g.A)((0,g.A)({},t),{},{transferList:a})))}async getSprites(e){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(e)}getGlyphs(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)}async _getTilePayload(e,t,i){const n=L.A.pool.acquire(e.id),a=this._layer.sourceNameToSource[t],{level:r,row:s,col:l}=n;L.A.pool.release(n);try{return{protobuff:await a.requestTile(r,s,l,i),sourceName:t}}catch(c){if((0,o.zf)(c))throw c;return{protobuff:null,sourceName:t}}}async _getRefKeys(e,t){const i=this._layer.sourceNameToSource,n=new Array;for(const a in i){const r=i[a].getRefKey(e,t);n.push(r)}return(0,o.Lx)(n)}_getSourcesData(e,t,i){const n=[];for(let a=0;a<t.length;a++)if(null==t[a].value||null==e[a])n.push(null);else{const r=t[a].value,s=this._getTilePayload(r,e[a],i);n.push(s)}return(0,o.Lx)(n).then(e=>{const i={},n=[];for(let a=0;a<e.length;a++){const r=e[a].value;if(r&&r.protobuff&&r.protobuff.byteLength>0){const e=t[a].value.id;i[r.sourceName]={refKey:e,protobuff:r.protobuff},n.push(r.protobuff)}}return{sourceName2DataAndRefKey:i,transferList:n}})}}var U=i(542),k=i(88235),z=i(40181);class V extends z.A{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(e){const t=L.A.pool.acquire(e),i=0===t.level?null:L.A.getId(t.level-1,t.row>>1,t.col>>1,t.world);return L.A.pool.release(t),i}getTileCoverage(e,t){let i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],n=arguments.length>3?arguments[3]:void 0;const a=super.getTileCoverage(e,t,i,n);if(!a)return a;const r=1<<a.lodInfo.level;return a.spans=a.spans.filter(e=>e.row>=0&&e.row<r),a}scaleToLevel(e){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[e])return this._levelByScale[e];{const t=this._fullCacheLodInfos;if(e>t[0].scale)return t[0].level;let i,n;for(let a=0;a<t.length-1;a++)if(n=t[a+1],e>n.scale)return i=t[a],i.level+(i.scale-e)/(i.scale-n.scale);return t[t.length-1].level}}_initializeFullCacheLODs(e){let t;if(0===e[0].level)t=e.map(e=>({level:e.level,resolution:e.resolution,scale:e.scale}));else{const e=this.tileInfo.size[0],i=this.tileInfo.spatialReference;t=k.A.create({size:e,spatialReference:i}).lods.map(e=>({level:e.level,resolution:e.resolution,scale:e.scale}))}for(let i=0;i<t.length;i++)this._levelByScale[t[i].scale]=t[i].level;this._fullCacheLodInfos=t}}class O extends A{constructor(e,t,i,n){super(e,t,i,e.tileInfo.lods.length-1),this._memCache=n,this._vectorTiles=new Map,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map,this._tileInfoView=new V(e.tileInfo,e.fullExtent)}destroy(){super.destroy(),this._ongoingRequestToController.forEach(e=>e.abort()),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear(),this._vectorTiles.clear()}async getVectorTile(e,t){var i,n;const a=new L.A(e[0],e[1],e[2],0);let r=null!==(i=this._vectorTiles.get(a.id))&&void 0!==i?i:this._memCache.get(a.id);if(r)return r.retain(),r;const s=await this._getVectorTileData(a);if((0,o.Te)(t),!this._layer)return null;if(r=null!==(n=this._vectorTiles.get(a.id))&&void 0!==n?n:this._memCache.get(a.id),r)return r.retain(),r;const l=this._layer.tileInfo.getTileBounds((0,_.vt)(),a),c=this._tileInfoView.getTileResolution(e[0]);return r=new U.c(a,c,l[0],l[3],f.kY,f.kY,this._styleRepository,this),r.setData(s),s&&(r.retain(),this._memCache.put(a.id,r,d.Ti),this._vectorTiles.set(a.id,r)),r.neededForCoverage=!0,r.transforms.tileUnitsToPixels=(0,p.fA)(1/8,0,0,0,1/8,0,0,0,1),r}updateTileSize(e){this._memCache.updateSize(e.id)}onDisposeTile(e){this._vectorTiles.delete(e.id)}_getVectorTileData(e){const t=e.id;if(this._ongoingTileRequests.has(t))return this._ongoingTileRequests.get(t);const i=new AbortController,n={signal:i.signal},a=this._getParsedVectorTileData(e,n).then(e=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),e)).catch(()=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),null));return this._ongoingTileRequests.set(t,a),this._ongoingRequestToController.set(t,i),a}_getParsedVectorTileData(e,t){return this.fetchTileData(e,t).then(i=>this.parseTileData({key:e,data:i},t))}}var F=i(15941),N=i(28608),H=i(5095);class W{constructor(){this.name=this.constructor.name||"UnnamedBrush",this.brushEffect=null}prepareState(e,t){}draw(e,t,i){}drawMany(e,t,i){for(const n of t)n.visible&&this.draw(e,n,i)}}var B=i(93345),q=i(36911),Z=i(9243);const G=1/65536;var K=i(59422),Y=i(62887);Math.PI;const $=256/360;Math.LN2;function j(e,t){return(e%=t)>=0?e:e+t}function X(e){return j(e*$,256)}const Q=1/65536;const J={vtlBackground:class extends W{constructor(){super(...arguments),this._color=(0,N.fA)(1,0,0,1),this._patternMatrix=(0,p.vt)(),this._programOptions={id:!1,pattern:!1}}dispose(){this._vao=(0,s.WD)(this._vao)}drawMany(e,t){const{context:i,painter:n,requestRender:a,allowDelayedRender:r}=e;this._loadWGLResources(e);const s=e.displayLevel,o=e.styleLayer,l=o.backgroundMaterial,c=n.vectorTilesMaterialManager,h=o.getPaintValue("background-color",s),u=o.getPaintValue("background-opacity",s),d=o.getPaintValue("background-pattern",s),p=void 0!==d,_=1|window.devicePixelRatio,f=e.spriteMosaic;let g,m;const v=_>H.C_?2:1,y=this._programOptions;y.pattern=p;const w=c.getMaterialProgram(i,l,y);if(!r||null==a||w.compiled){if(i.bindVAO(this._vao),i.useProgram(w),p){const e=f.getMosaicItemPosition(d,!0);if(null!=e){const{tl:t,br:n,page:a}=e;g=n[0]-t[0],m=n[1]-t[1];const r=f.getPageSize(a);null!=r&&(f.bind(i,9729,a,H.$U),w.setUniform4f("u_tlbr",t[0],t[1],n[0],n[1]),w.setUniform2fv("u_mosaicSize",r),w.setUniform1i("u_texture",H.$U))}w.setUniform1f("u_opacity",u)}else{const e=h[3]*u;this._color[0]=e*h[0],this._color[1]=e*h[1],this._color[2]=e*h[2],this._color[3]=e,w.setUniform4fv("u_color",this._color)}w.setUniform1f("u_depth",o.z||0);for(const e of t){if(w.setUniform1f("u_coord_range",e.rangeX),w.setUniformMatrix3fv("u_dvsMat3",e.transforms.displayViewScreenMat3),p){const t=Math.max(2**(Math.round(s)-e.key.level),1),i=v*e.width*t,n=i/(0,F.yR)(g),a=i/(0,F.yR)(m);this._patternMatrix[0]=n,this._patternMatrix[4]=a,w.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix)}i.setStencilFunction(514,0,255),i.drawArrays(B.WR.TRIANGLE_STRIP,0,4)}}else a()}_loadWGLResources(e){if(this._vao)return;const{context:t,styleLayer:i}=e,n=i.backgroundMaterial,a=new Int8Array([0,0,1,0,0,1,1,1]),r=new Z.R(t,n.geometryLayout,a);this._vao=new q.Z(t,r)}},vtlFill:class extends W{constructor(){super(...arguments),this._fillProgramOptions={id:!1,pattern:!1},this._outlineProgramOptions={id:!1}}dispose(){}drawMany(e,t){const{displayLevel:i,renderPass:n,spriteMosaic:a,styleLayerUID:r}=e;let s=!1;for(const v of t)if(v.layerData.has(r)){const e=v.layerData.get(r);if(e.fillIndexCount>0||e.outlineIndexCount>0){s=!0;break}}if(!s)return;const o=e.styleLayer,l=o.getPaintProperty("fill-pattern"),c=void 0!==l,h=c&&l.isDataDriven;let u;if(c&&!h){const e=l.getValue(i);u=a.getMosaicItemPosition(e,!0)}const d=!c&&o.getPaintValue("fill-antialias",i);let p=!0,_=1;if(!c){const e=o.getPaintProperty("fill-color"),t=o.getPaintProperty("fill-opacity");if((null===e||void 0===e||!e.isDataDriven)&&(null===t||void 0===t||!t.isDataDriven)){const e=o.getPaintValue("fill-color",i);_=o.getPaintValue("fill-opacity",i)*e[3],_>=1&&(p=!1)}}if(p&&"opaque"===n)return;const f=o.getPaintValue("fill-translate",i),g=o.getPaintValue("fill-translate-anchor",i);(p||"translucent"!==n)&&this._drawFill(e,r,o,t,f,g,c,u,h);const m=!o.hasDataDrivenOutlineColor&&o.outlineUsesFillColor&&_<1;d&&"opaque"!==n&&!m&&this._drawOutline(e,r,o,t,f,g)}_drawFill(e,t,i,n,a,r,s,o,l){if(s&&!l&&null==o)return;const{context:c,displayLevel:h,state:u,painter:d,pixelRatio:p,spriteMosaic:_,requestRender:f,allowDelayedRender:g}=e,m=i.fillMaterial,v=d.vectorTilesMaterialManager,y=p>H.C_?2:1,w=this._fillProgramOptions;w.pattern=s;const x=v.getMaterialProgram(c,m,w);if(g&&null!=f&&!x.compiled)return void f();if(c.useProgram(x),null!=o){const{page:e}=o,t=_.getPageSize(e);null!=t&&(_.bind(c,9729,e,H.$U),x.setUniform2fv("u_mosaicSize",t),x.setUniform1i("u_texture",H.$U))}x.setUniformMatrix3fv("u_displayMat3",1===r?u.displayMat3:u.displayViewMat3),x.setUniform2fv("u_fillTranslation",a),x.setUniform1f("u_depth",i.z+G);let S=-1;for(const b of n){if(!b.layerData.has(t))continue;b.key.level!==S&&(S=b.key.level,m.setDataUniforms(x,h,i,S,_));const e=b.layerData.get(t);if(!e.fillIndexCount)continue;e.prepareForRendering(c);const n=e.fillVAO;if(null!=n){if(c.bindVAO(n),x.setUniformMatrix3fv("u_dvsMat3",b.transforms.displayViewScreenMat3),c.setStencilFunction(514,b.stencilRef,255),s){const e=Math.max(2**(Math.round(h)-b.key.level),1),t=b.rangeX/(y*b.width*e);x.setUniform1f("u_patternFactor",t)}if(l){const t=e.patternMap;if(!t)continue;for(const[e,i]of t){const t=_.getPageSize(e);null!=t&&(_.bind(c,9729,e,H.$U),x.setUniform2fv("u_mosaicSize",t),x.setUniform1i("u_texture",H.$U),c.drawElements(B.WR.TRIANGLES,i[1],B.pe.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]))}}else c.drawElements(B.WR.TRIANGLES,e.fillIndexCount,B.pe.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*e.fillIndexStart);b.triangleCount+=e.fillIndexCount/3}}}_drawOutline(e,t,i,n,a,r){const{context:s,displayLevel:o,state:l,painter:c,pixelRatio:h,spriteMosaic:u,requestRender:d,allowDelayedRender:p}=e,_=i.outlineMaterial,f=c.vectorTilesMaterialManager,g=.75/h,m=this._outlineProgramOptions,v=f.getMaterialProgram(s,_,m);if(p&&null!=d&&!v.compiled)return void d();s.useProgram(v),v.setUniformMatrix3fv("u_displayMat3",1===r?l.displayMat3:l.displayViewMat3),v.setUniform2fv("u_fillTranslation",a),v.setUniform1f("u_depth",i.z+G),v.setUniform1f("u_outline_width",g);let y=-1;for(const w of n){if(!w.layerData.has(t))continue;w.key.level!==y&&(y=w.key.level,_.setDataUniforms(v,o,i,y,u));const e=w.layerData.get(t);if(e.prepareForRendering(s),!e.outlineIndexCount)continue;const n=e.outlineVAO;null!=n&&(s.bindVAO(n),v.setUniformMatrix3fv("u_dvsMat3",w.transforms.displayViewScreenMat3),s.setStencilFunction(514,w.stencilRef,255),s.drawElements(B.WR.TRIANGLES,e.outlineIndexCount,B.pe.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*e.outlineIndexStart),w.triangleCount+=e.outlineIndexCount/3)}}},vtlLine:class extends W{constructor(){super(...arguments),this._programOptions={id:!1,pattern:!1,sdf:!1}}dispose(){}drawMany(e,t){const{context:i,displayLevel:n,state:a,painter:r,pixelRatio:s,spriteMosaic:o,styleLayerUID:l,requestRender:c,allowDelayedRender:h}=e;if(!t.some(e=>{var t,i;return null!==(t=null===(i=e.layerData.get(l))||void 0===i?void 0:i.lineIndexCount)&&void 0!==t&&t}))return;const u=e.styleLayer,d=u.lineMaterial,p=r.vectorTilesMaterialManager,_=u.getPaintValue("line-translate",n),f=u.getPaintValue("line-translate-anchor",n),g=u.getPaintProperty("line-pattern"),m=void 0!==g,v=m&&g.isDataDriven;let y,w;if(m&&!v){const e=g.getValue(n);y=o.getMosaicItemPosition(e)}let x=!1;if(!m){const e=u.getPaintProperty("line-dasharray");if(w=void 0!==e,x=w&&e.isDataDriven,w&&!x){const t=e.getValue(n),i=u.getDashKey(t,u.getLayoutValue("line-cap",n));y=o.getMosaicItemPosition(i)}}const S=1/s,b=this._programOptions;b.pattern=m,b.sdf=w;const M=p.getMaterialProgram(i,d,b);if(h&&null!=c&&!M.compiled)return void c();if(i.useProgram(M),M.setUniformMatrix3fv("u_displayViewMat3",a.displayViewMat3),M.setUniformMatrix3fv("u_displayMat3",1===f?a.displayMat3:a.displayViewMat3),M.setUniform2fv("u_lineTranslation",_),M.setUniform1f("u_depth",u.z),M.setUniform1f("u_antialiasing",S),y&&null!=y){const{page:e}=y,t=o.getPageSize(e);null!=t&&(o.bind(i,9729,e,H.$U),M.setUniform2fv("u_mosaicSize",t),M.setUniform1i("u_texture",H.$U))}let P=-1;for(const C of t){if(!C.layerData.has(l))continue;C.key.level!==P&&(P=C.key.level,d.setDataUniforms(M,n,u,P,o));const e=2**(n-P)/s;M.setUniform1f("u_zoomFactor",e);const t=C.layerData.get(l);if(!t.lineIndexCount)continue;t.prepareForRendering(i);const a=t.vao;if(null!=a){if(i.bindVAO(a),M.setUniformMatrix3fv("u_dvsMat3",C.transforms.displayViewScreenMat3),i.setStencilFunction(514,C.stencilRef,255),v||x){const e=t.patternMap;if(!e)continue;for(const[t,n]of e){const e=o.getPageSize(t);null!=e&&(o.bind(i,9729,t,H.$U),M.setUniform2fv("u_mosaicSize",e),M.setUniform1i("u_texture",H.$U),i.drawElements(B.WR.TRIANGLES,n[1],B.pe.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*n[0]))}}else i.drawElements(B.WR.TRIANGLES,t.lineIndexCount,B.pe.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t.lineIndexStart);C.triangleCount+=t.lineIndexCount/3}}}},vtlCircle:class extends W{constructor(){super(...arguments),this._programOptions={id:!1}}dispose(){}drawMany(e,t){const{context:i,displayLevel:n,requiredLevel:a,state:r,painter:s,spriteMosaic:o,styleLayerUID:l,requestRender:c,allowDelayedRender:h}=e;if(!t.some(e=>{var t,i;return null!==(t=null===(i=e.layerData.get(l))||void 0===i?void 0:i.circleIndexCount)&&void 0!==t&&t}))return;const u=e.styleLayer,d=u.circleMaterial,p=s.vectorTilesMaterialManager,_=u.getPaintValue("circle-translate",n),f=u.getPaintValue("circle-translate-anchor",n),g=this._programOptions,m=p.getMaterialProgram(i,d,g);if(h&&null!=c&&!m.compiled)return void c();i.useProgram(m),m.setUniformMatrix3fv("u_displayMat3",1===f?r.displayMat3:r.displayViewMat3),m.setUniform2fv("u_circleTranslation",_),m.setUniform1f("u_depth",u.z),m.setUniform1f("u_antialiasingWidth",1.2);let v=-1;for(const y of t){if(!y.layerData.has(l))continue;y.key.level!==v&&(v=y.key.level,d.setDataUniforms(m,n,u,v,o));const e=y.layerData.get(l);if(!e.circleIndexCount)continue;e.prepareForRendering(i);const t=e.vao;null!=t&&(i.bindVAO(t),m.setUniformMatrix3fv("u_dvsMat3",y.transforms.displayViewScreenMat3),a!==y.key.level?i.setStencilFunction(514,y.stencilRef,255):i.setStencilFunction(516,255,255),i.drawElements(B.WR.TRIANGLES,e.circleIndexCount,B.pe.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*e.circleIndexStart),y.triangleCount+=e.circleIndexCount/3)}}},vtlSymbol:class extends W{constructor(){super(...arguments),this._iconProgramOptions={id:!1,sdf:!1},this._sdfProgramOptions={id:!1},this._spritesTextureSize=(0,K.vt)()}dispose(){}drawMany(e,t){const i=e.styleLayer;this._drawIcons(e,i,t),this._drawText(e,i,t)}_drawIcons(e,t,i){const{context:n,displayLevel:a,painter:r,spriteMosaic:s,state:o,styleLayerUID:l,requestRender:c,allowDelayedRender:h}=e,u=t.iconMaterial,d=r.vectorTilesMaterialManager;let p,_=!1;for(const M of i)if(M.layerData.has(l)&&(p=M.layerData.get(l),p.iconPerPageElementsMap.size>0)){_=!0;break}if(!_)return;const f=t.getPaintValue("icon-translate",a),g=t.getPaintValue("icon-translate-anchor",a);let m=t.getLayoutValue("icon-rotation-alignment",a);2===m&&(m=0===t.getLayoutValue("symbol-placement",a)?1:0);const v=0===m,y=t.getLayoutValue("icon-keep-upright",a)&&v,w=p.isIconSDF,x=this._iconProgramOptions;x.sdf=w;const S=d.getMaterialProgram(n,u,x);if(h&&null!=c&&!S.compiled)return void c();n.useProgram(S),S.setUniformMatrix3fv("u_displayViewMat3",0===m?o.displayViewMat3:o.displayMat3),S.setUniformMatrix3fv("u_displayMat3",1===g?o.displayMat3:o.displayViewMat3),S.setUniform2fv("u_iconTranslation",f),S.setUniform1f("u_depth",t.z),S.setUniform1f("u_mapRotation",X(o.rotation)),S.setUniform1f("u_keepUpright",y?1:0),S.setUniform1f("u_level",10*a),S.setUniform1i("u_texture",H.$U),S.setUniform1f("u_fadeDuration",Y.zk/1e3),S.setUniform1i("u_isStencilPass",e.stencilSymbols?1:0);let b=-1;for(const M of i){if(!M.layerData.has(l))continue;if(M.key.level!==b&&(b=M.key.level,u.setDataUniforms(S,a,t,b,s)),p=M.layerData.get(l),0===p.iconPerPageElementsMap.size)continue;p.prepareForRendering(n),p.updateOpacityInfo();const i=p.iconVAO;if(null!=i){n.bindVAO(i),S.setUniformMatrix3fv("u_dvsMat3",M.transforms.displayViewScreenMat3),S.setUniform1f("u_time",(performance.now()-p.lastOpacityUpdate)/1e3);for(const[t,i]of p.iconPerPageElementsMap)this._renderIconRange(e,S,i,t,M)}}}_renderIconRange(e,t,i,n,a){const{context:r,spriteMosaic:s}=e;this._spritesTextureSize[0]=s.getWidth(n)/4,this._spritesTextureSize[1]=s.getHeight(n)/4,t.setUniform2fv("u_mosaicSize",this._spritesTextureSize),s.bind(r,9729,n,H.$U),this._setStencilState(e,a),r.drawElements(B.WR.TRIANGLES,i[1],B.pe.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]),a.triangleCount+=i[1]/3}_drawText(e,t,i){const{context:n,displayLevel:a,glyphMosaic:r,painter:s,pixelRatio:o,spriteMosaic:l,state:c,styleLayerUID:h,requestRender:u,allowDelayedRender:d}=e,p=t.textMaterial,_=s.vectorTilesMaterialManager;let f,g=!1;for(const L of i)if(L.layerData.has(h)&&(f=L.layerData.get(h),f.glyphPerPageElementsMap.size>0)){g=!0;break}if(!g)return;const m=t.getPaintProperty("text-opacity");if(m&&!m.isDataDriven&&0===m.getValue(a))return;const v=t.getPaintProperty("text-color"),y=!v||v.isDataDriven||v.getValue(a)[3]>0,w=t.getPaintProperty("text-halo-width"),x=t.getPaintProperty("text-halo-color"),S=(!w||w.isDataDriven||w.getValue(a)>0)&&(!x||x.isDataDriven||x.getValue(a)[3]>0);if(!y&&!S)return;let b=t.getLayoutValue("text-rotation-alignment",a);2===b&&(b=0===t.getLayoutValue("symbol-placement",a)?1:0);const M=0===b,P=t.getLayoutValue("text-keep-upright",a)&&M,C=.8*3/o;this._glyphTextureSize||(this._glyphTextureSize=(0,K.fA)(r.width/4,r.height/4));const T=t.getPaintValue("text-translate",a),R=t.getPaintValue("text-translate-anchor",a),I=this._sdfProgramOptions,D=_.getMaterialProgram(n,p,I);if(d&&null!=u&&!D.compiled)return void u();n.useProgram(D),D.setUniformMatrix3fv("u_displayViewMat3",0===b?c.displayViewMat3:c.displayMat3),D.setUniformMatrix3fv("u_displayMat3",1===R?c.displayMat3:c.displayViewMat3),D.setUniform2fv("u_textTranslation",T),D.setUniform1f("u_depth",t.z+Q),D.setUniform2fv("u_mosaicSize",this._glyphTextureSize),D.setUniform1f("u_mapRotation",X(c.rotation)),D.setUniform1f("u_keepUpright",P?1:0),D.setUniform1f("u_level",10*a),D.setUniform1i("u_texture",H.mg),D.setUniform1f("u_antialiasingWidth",C),D.setUniform1f("u_fadeDuration",Y.zk/1e3);let E=-1;for(const L of i){if(!L.layerData.has(h))continue;if(L.key.level!==E&&(E=L.key.level,p.setDataUniforms(D,a,t,E,l)),f=L.layerData.get(h),0===f.glyphPerPageElementsMap.size)continue;f.prepareForRendering(n),f.updateOpacityInfo();const i=f.textVAO;if(null==i)continue;n.bindVAO(i),D.setUniformMatrix3fv("u_dvsMat3",L.transforms.displayViewScreenMat3),this._setStencilState(e,L);const s=(performance.now()-f.lastOpacityUpdate)/1e3;D.setUniform1f("u_time",s),f.glyphPerPageElementsMap.forEach((e,t)=>{this._renderGlyphRange(n,e,t,r,D,S,y,L)})}}_renderGlyphRange(e,t,i,n,a,r,s,o){n.bind(e,9729,i,H.mg),r&&(a.setUniform1f("u_halo",1),e.drawElements(B.WR.TRIANGLES,t[1],B.pe.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),o.triangleCount+=t[1]/3),s&&(a.setUniform1f("u_halo",0),e.drawElements(B.WR.TRIANGLES,t[1],B.pe.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),o.triangleCount+=t[1]/3)}_setStencilState(e,t){const{context:i,is3D:n,stencilSymbols:a}=e;if(i.setStencilTestEnabled(!0),a)return i.setStencilWriteMask(255),void i.setStencilFunction(519,t.stencilRef,255);i.setStencilWriteMask(0),n?i.setStencilFunction(514,t.stencilRef,255):i.setStencilFunction(516,255,255)}}},ee={background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nuniform highp int u_isStencilPass;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\nconst float alphaCutoff = 1.0 / 255.5;\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\nif (u_isStencilPass == 1 && texColor.a < alphaCutoff) {\ndiscard;\n}\ngl_FragColor = v_opacity * texColor;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\nv_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n}","line.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}","util.glsl":"float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}"}};const te=new class{constructor(e){this._readFile=e}resolveIncludes(e){return this._resolve(e)}_resolve(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Map;if(t.has(e))return t.get(e);const i=this._read(e);if(!i)throw new Error("cannot find shader file ".concat(e));const n=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let a=n.exec(i);const r=[];for(;null!=a;)r.push({path:a[1],start:a.index,length:a[0].length}),a=n.exec(i);let s=0,o="";return r.forEach(e=>{o+=i.slice(s,e.start),o+=t.has(e.path)?"":this._resolve(e.path,t),s=e.start+e.length}),o+=i.slice(s),t.set(e,o),o}_read(e){return this._readFile(e)}}(function(e){let t=ee;return e.split("/").forEach(e=>{t&&(t=t[e])}),t});function ie(e){return te.resolveIncludes(e)}function ne(e){const{options:t,value:i}=e;return"number"==typeof t[i]}function ae(e){let t="";for(const i in e){const n=e[i];if("boolean"==typeof n)n&&(t+="#define ".concat(i,"\n"));else if("number"==typeof n)t+="#define ".concat(i," ").concat(n.toFixed(),"\n");else if("object"==typeof n)if(ne(n)){const{value:e,options:a,namespace:r}=n,s=r?"".concat(r,"_"):"";for(const i in a)t+="#define ".concat(s).concat(i," ").concat(a[i].toFixed(),"\n");t+="#define ".concat(i," ").concat(s).concat(e,"\n")}else{const e=n.options;let a=0;for(const i in e)t+="#define ".concat(e[i]," ").concat((a++).toFixed(),"\n");t+="#define ".concat(i," ").concat(e[n.value],"\n")}}return t}const re=e=>ae({PATTERN:e.pattern}),se={shaders:e=>({vertexShader:re(e)+ie("background/background.vert"),fragmentShader:re(e)+ie("background/background.frag")})},oe={shaders:e=>({vertexShader:ie("circle/circle.vert"),fragmentShader:ie("circle/circle.frag")})},le=e=>ae({PATTERN:e.pattern}),ce={shaders:e=>({vertexShader:le(e)+ie("fill/fill.vert"),fragmentShader:le(e)+ie("fill/fill.frag")})},he={shaders:e=>({vertexShader:ie("outline/outline.vert"),fragmentShader:ie("outline/outline.frag")})},ue=e=>ae({SDF:e.sdf}),de={shaders:e=>({vertexShader:ue(e)+ie("icon/icon.vert"),fragmentShader:ue(e)+ie("icon/icon.frag")})},pe=e=>ae({PATTERN:e.pattern,SDF:e.sdf}),_e={shaders:e=>({vertexShader:pe(e)+ie("line/line.vert"),fragmentShader:pe(e)+ie("line/line.frag")})},fe={shaders:e=>({vertexShader:ie("text/text.vert"),fragmentShader:ie("text/text.frag")})};class ge{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach(e=>e.dispose()),this._programByKey.clear()}getMaterialProgram(e,t,i){const n=t.key<<3|this._getMaterialOptionsValue(t.type,i);if(this._programByKey.has(n))return this._programByKey.get(n);const a=this._getProgramTemplate(t.type),{shaders:r}=a,{vertexShader:s,fragmentShader:o}=r(i),l=t.getShaderHeader(),c=t.getShaderMain(),h=s.replace("#pragma header",l).replace("#pragma main",c),u=e.programCache.acquire(h,o,t.getAttributeLocations());return this._programByKey.set(n,u),u}_getMaterialOptionsValue(e,t){switch(e){case 0:case 1:return(t.pattern?1:0)<<1;case 2:case 5:case 6:default:return 0;case 3:{const e=t;return(e.sdf?1:0)<<2|(e.pattern?1:0)<<1}case 4:return(t.sdf?1:0)<<1}}_getProgramTemplate(e){switch(e){case 0:return se;case 5:return oe;case 1:return ce;case 4:return de;case 3:return _e;case 2:return he;case 6:return fe;default:return null}}}const me=1e-6;class ve{constructor(e,t){this.spriteMosaic=e,this.glyphMosaic=t,this._brushCache={vtlBackground:null,vtlFill:null,vtlLine:null,vtlCircle:null,vtlSymbol:null},this._vtlMaterialManager=new ge}dispose(){var e,t,i,n,a;null!==(e=this._brushCache.vtlBackground)&&void 0!==e&&e.dispose(),null!==(t=this._brushCache.vtlFill)&&void 0!==t&&t.dispose(),null!==(i=this._brushCache.vtlLine)&&void 0!==i&&i.dispose(),null!==(n=this._brushCache.vtlCircle)&&void 0!==n&&n.dispose(),null!==(a=this._brushCache.vtlSymbol)&&void 0!==a&&a.dispose(),this._brushCache=null,this._vtlMaterialManager=(0,s.WD)(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawSymbols(e,t,i){const n=i.layers;e.renderPass="translucent";let a=this._brushCache.vtlSymbol;null==a&&(a=new J.vtlSymbol,this._brushCache.vtlSymbol=a),ye[0]=t;for(let r=0;r<n.length;r++){const t=n[r];if(3!==t.type)continue;const i=t.getLayoutProperty("visibility");if(i&&1===i.getValue())continue;const s=e.displayLevel;void 0!==t.minzoom&&t.minzoom>s+me||void 0!==t.maxzoom&&t.maxzoom<=s-me||(e.styleLayerUID=t.uid,e.styleLayer=t,a.drawMany(e,ye))}ye[0]=null}drawBackground(e,t,i){if(0===i.backgroundBucketIds.length)return;const{context:n,displayLevel:a,requiredLevel:r}=e;t.key.level=r,n.setBlendingEnabled(!0),n.setDepthTestEnabled(!1),n.setStencilTestEnabled(!1),e.renderPass="background";let s=this._brushCache.vtlBackground;null==s&&(s=new J.vtlBackground,this._brushCache.vtlBackground=s),ye[0]=t,i.backgroundBucketIds.forEach(t=>{const n=i.getLayerById(t);if(0!==n.type)return;const r=n.getLayoutProperty("visibility");r&&1===r.getValue()||void 0!==n.minzoom&&n.minzoom>a+me||void 0!==n.maxzoom&&n.maxzoom<=a-me||(e.styleLayerUID=n.uid,e.styleLayer=n,s.drawMany(e,ye))}),ye[0]=null}drawTile(e,t,i,n){const{context:a}=e,r=i.layers;a.setBlendingEnabled(!1),a.setDepthTestEnabled(!0),a.setDepthWriteEnabled(!0),a.setDepthFunction(515);const s=r.filter(e=>{if(null!=n&&n!==e.type||!t.layerData.has(e.uid))return!1;const i=e.getLayoutProperty("visibility");return 1!==(null===i||void 0===i?void 0:i.getValue())});e.renderPass="opaque";for(let o=s.length-1;o>=0;--o)this._renderStyleLayer(s[o],e,t);a.setDepthWriteEnabled(!1),a.setBlendingEnabled(!0),a.setBlendFunctionSeparate(1,771,1,771),e.renderPass="translucent",s.forEach(i=>this._renderStyleLayer(i,e,t)),a.setDepthTestEnabled(!1),a.bindVAO(null)}_renderStyleLayer(e,t,i){const{renderPass:n}=t;let a;switch(e.type){case 0:if("background"!==n)return;a=this._brushCache.vtlBackground,a||(a=new J.vtlBackground,this._brushCache.vtlBackground=a);break;case 1:if("opaque"!==n&&"translucent"!==t.renderPass)return;a=this._brushCache.vtlFill,null==a&&(a=new J.vtlFill,this._brushCache.vtlFill=a);break;case 2:if("translucent"!==n)return;a=this._brushCache.vtlLine,null==a&&(a=new J.vtlLine,this._brushCache.vtlLine=a);break;case 4:if("translucent"!==n)return;a=this._brushCache.vtlCircle,null==a&&(a=new J.vtlCircle,this._brushCache.vtlCircle=a);break;case 3:if("translucent"!==n)return;a=this._brushCache.vtlSymbol,null==a&&(a=new J.vtlSymbol,this._brushCache.vtlSymbol=a)}const{displayLevel:r}=t,{minzoom:s,maxzoom:o}=e;if(void 0!==s&&s>r+me||void 0!==o&&o<=r-me)return;const{context:l}=t;l.setStencilTestEnabled(!1),l.setStencilWriteMask(0),t.styleLayerUID=e.uid,t.styleLayer=e,ye[0]=i,a.drawMany(t,ye),ye[0]=null}}const ye=[null];var we=i(45995),xe=i(83491),Se=i(96453),be=i(4225),Me=i(91196);let Pe=class extends((0,Se.E)((0,xe.w)(Me.A))){constructor(){super(...arguments),this._tileHandlerController=null,this.type="vector-tile-3d",this.levelShift=(0,r.A)("disable-feature:vtl-level-shift")?0:1}initialize(){if(null==this.layer.fullExtent)return void this.addResolvingPromise(Promise.reject(new a.A("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:e,spatialReference:t,state:i,viewingMode:n}=this.view,r="local"===n&&!(0,be.bA)(t)||be.t6.force512VTL?this.layer.tileInfo:this.layer.tileInfo.getCompatibleForVTL(256),s=this._getTileInfoSupportError(r,this.layer.fullExtent);if(null!=s)return this.addResolvingPromise(Promise.reject(s));const c=(0,l.C_)(()=>{var e;return null===(e=this.view)||void 0===e||null===(e=e.basemapTerrain)||void 0===e?void 0:e.tilingSchemeLocked}).then(()=>{var t,i;const n=e.tilingScheme,a=n.pixelSize,r=256===a?1:2,s=null!==(t=e.spatialReference)&&void 0!==t&&t.isGeographic&&256===a?1:0,o=null!==(i=e.spatialReference)&&void 0!==i&&i.isGeographic||256!==a?0:1;let l;this.schemaHelper=new u(r,s,this.levelShift+o),l=256===a||512===a?this.layer.tileInfo.getCompatibleForVTL(a):this.layer.tileInfo;const c=this._getTileInfoCompatibilityError(l,n);if(c)throw c;this.tileInfo=l});this._tileHandlerController=new AbortController;const h=this.view.resourceController;this._memCache=h.memoryController.newCache("vtl-".concat(this.layer.uid),e=>e.release()),this.addHandles((0,l.wB)(()=>this.view.qualitySettings.memoryLimit,e=>this._memCache.maxSize=Math.ceil(e/10*1048576),l.pc));const d=new we.A(this.layer.currentStyleInfo.style);this._tileHandler=new O(this.layer,d,i.contentPixelRatio,this._memCache);const p=this._tileHandlerController.signal,_=function(e){return t=>e.immediate.schedule(t)}(h),f=this._tileHandler.start({signal:p,schedule:_}),g=this._tileHandler.spriteMosaic;g.then(e=>{!(0,o.G4)(p)&&this._tileHandler&&(this.painter=new ve(e,this._tileHandler.glyphMosaic))}),f.then(()=>this._tileHandlerController=null);const m=()=>{var e,t;this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const i=this.layer.currentStyleInfo.style,n=null!==(e=null===(t=this.view.state)||void 0===t?void 0:t.contentPixelRatio)&&void 0!==e?e:1,a=new we.A(i),r=new O(this.layer,a,n,this._memCache),s=r.start({signal:this._tileHandlerController.signal,schedule:_}),o=r.spriteMosaic;s.then(()=>this._tileHandlerController=null),this._updatingHandles.addPromise(Promise.all([s,o]).then(e=>{let[,t]=e;const i=this._tileHandler,n=this.painter;this.painter=new ve(t,r.glyphMosaic),this._tileHandler=r,this.emit("data-changed"),i.destroy(),n&&n.dispose()}))};this._updatingHandles.add(()=>{var e;return{style:this.layer.currentStyleInfo.style,pixelRatio:null===(e=this.view.state)||void 0===e?void 0:e.contentPixelRatio}},m),this.addHandles([this.layer.on("paint-change",()=>this.emit("data-changed")),this.layer.on("style-layer-change",m),this.layer.on("delete-style-layer",m),this.layer.on("spriteSource-change",()=>this.emit("data-changed")),this.layer.on("layout-change",()=>this.emit("data-changed")),this.layer.on("style-layer-visibility-change",()=>this.emit("data-changed"))]);const v=Promise.all([c,f,g]);this.addResolvingPromise(v)}destroy(){this.painter=(0,s.WD)(this.painter),this._tileHandlerController=(0,s.DC)(this._tileHandlerController),this._tileHandler=(0,s.pR)(this._tileHandler),this._memCache=(0,s.pR)(this._memCache)}get contentZoom(){return(0,r.A)("disable-feature:vtl-level-shift")?1:this.view.qualitySettings.tiledSurface.vtlContentZoom}get displayLevelRange(){const e=this.tileInfo.lods,t=this.layer.minScale||e[0].scale,i=this.layer.maxScale||e[e.length-1].scale,n=this.levelRangeFromScaleRange(t,i);return this.layer.maxScale?n.maxLevel++:n.maxLevel+=this.levelShift,n}get dataScaleRange(){const e=this.tileInfo.lods;return{minScale:e[0].scale,maxScale:e[e.length-1].scale}}get dataLevelRange(){const{minScale:e,maxScale:t}=this.dataScaleRange,i=this.levelRangeFromScaleRange(e,t);return 1===i.minLevel&&256===this.tileInfo.size[0]&&(i.minLevel=0),i.maxLevel+=this.levelShift,i}async fetchTile(e,t){const i=this.schemaHelper.getLevelRowColumn(e);return this._tileHandler.getVectorTile(i,t)}get hasVisibleFeatures(){return!0}};(0,n.Cg)([(0,c.MZ)()],Pe.prototype,"layer",void 0),(0,n.Cg)([(0,c.MZ)()],Pe.prototype,"levelShift",void 0),(0,n.Cg)([(0,c.MZ)()],Pe.prototype,"contentZoom",null),(0,n.Cg)([(0,c.MZ)()],Pe.prototype,"displayLevelRange",null),(0,n.Cg)([(0,c.MZ)()],Pe.prototype,"tileInfo",void 0),(0,n.Cg)([(0,c.MZ)()],Pe.prototype,"dataScaleRange",null),(0,n.Cg)([(0,c.MZ)()],Pe.prototype,"dataLevelRange",null),(0,n.Cg)([(0,c.MZ)()],Pe.prototype,"updatingProgressValue",void 0),Pe=(0,n.Cg)([(0,h.$)("esri.views.3d.layers.VectorTileLayerView3D")],Pe);const Ce=Pe},83491:(e,t,i)=>{i.d(t,{w:()=>h});var n=i(6326),a=i(54901),r=i(50346),s=i(68134),o=i(46053),l=(i(81806),i(76460),i(47249),i(87990)),c=i(47700);const h=e=>{const t=e;let i=class extends t{constructor(){super(...arguments),this.slicePlaneEnabled=!1,this.supportsHeightUnitConversion=!1}postscript(){super.postscript(),(0,c.jI)(this.layer)&&this.addResolvingPromise(this._validateHeightModelInfo())}async _validateHeightModelInfo(){const e=new AbortController,t=e.signal;this.addHandles((0,a.hA)(()=>e.abort())),await(0,s.C_)(()=>{var e;return null===(e=this.view.defaultsFromMap)||void 0===e?void 0:e.heightModelInfoReady},t),(0,r.Te)(t);const i=(0,c.Hu)(this.layer,this.view.heightModelInfo,this.supportsHeightUnitConversion);if(i)throw i}};return(0,n.Cg)([(0,o.MZ)()],i.prototype,"view",void 0),(0,n.Cg)([(0,o.MZ)()],i.prototype,"slicePlaneEnabled",void 0),i=(0,n.Cg)([(0,l.$)("esri.views.3d.layers.LayerView3D")],i),i}},91196:(e,t,i)=>{i.d(t,{A:()=>p});var n=i(6326),a=i(54099),r=i(5632),s=i(76460),o=i(30726),l=i(91291),c=i(46053),h=(i(81806),i(47249),i(87990)),u=i(19451),d=i(90992);let p=class extends((0,r.sA)((0,l.g)(a.nJ))){get spatialReferenceSupported(){return!0}constructor(e){super(e),this._updatingHandles=new u.U,this.layer=null,this.parent=null}initialize(){this.when().catch(e=>{if("layerview:create-error"!==e.name){var t;const i=this.layer&&this.layer.id||"no id",n=(null===(t=this.layer)||void 0===t?void 0:t.title)||"no title";s.A.getLogger(this).error("#resolve()","Failed to resolve layer view (layer title: '".concat(n,"', id: '").concat(i,"')"),e)}})}destroy(){this._updatingHandles=(0,o.pR)(this._updatingHandles),this._set("parent",null)}get fullOpacity(){var e,t,i,n;return(null!==(e=null===(t=this.layer)||void 0===t?void 0:t.opacity)&&void 0!==e?e:1)*(null!==(i=null===(n=this.parent)||void 0===n?void 0:n.fullOpacity)&&void 0!==i?i:1)}get suspended(){return this.destroyed||!this.canResume()}get suspendInfo(){return this.getSuspendInfo()}get legendEnabled(){var e;return!this.suspended&&!0===(null===(e=this.layer)||void 0===e?void 0:e.legendEnabled)}get updating(){var e;return!((null===(e=this._updatingHandles)||void 0===e||!e.updating)&&!this.isUpdating())}get updatingProgress(){return this.updating?0:1}get updateSuspended(){return this.suspended}get visible(){var e;return!0===(null===(e=this.layer)||void 0===e?void 0:e.visible)}set visible(e){this._overrideIfSome("visible",e)}get visibleAtCurrentScale(){return!0}get visibleAtCurrentTimeExtent(){var e;const t=this.view.timeExtent,i=null===(e=this.layer)||void 0===e?void 0:e.visibilityTimeExtent;return!t||!i||!t.intersection(i).isEmpty}canResume(){var e,t;const i=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return this.visible&&(null===(e=this.layer)||void 0===e?void 0:e.loaded)&&this.parent&&!this.parent.suspended&&(null===(t=this.view)||void 0===t?void 0:t.ready)&&(0,d.g7)(i)&&this.visibleAtCurrentScale&&this.visibleAtCurrentTimeExtent||!1}getSuspendInfo(){var e,t;const i=null!==(e=this.parent)&&void 0!==e&&e.suspended?this.parent.suspendInfo:{};null!==(t=this.view)&&void 0!==t&&t.ready||(i.viewNotReady=!0),this.layer&&this.layer.loaded||(i.layerNotLoaded=!0);const n=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return(0,d.g7)(n)&&this.visibleAtCurrentScale||(i.outsideScaleRange=!0),this.visibleAtCurrentTimeExtent||(i.outsideVisibilityTimeExtent=!0),this.visible||(i.layerInvisible=!0),i}isUpdating(){return!1}};(0,n.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"spatialReferenceSupported",null),(0,n.Cg)([(0,c.MZ)()],p.prototype,"view",void 0),(0,n.Cg)([(0,c.MZ)()],p.prototype,"fullOpacity",null),(0,n.Cg)([(0,c.MZ)()],p.prototype,"layer",void 0),(0,n.Cg)([(0,c.MZ)()],p.prototype,"parent",void 0),(0,n.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"suspended",null),(0,n.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"suspendInfo",null),(0,n.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"legendEnabled",null),(0,n.Cg)([(0,c.MZ)({type:Boolean,readOnly:!0})],p.prototype,"updating",null),(0,n.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"updatingProgress",null),(0,n.Cg)([(0,c.MZ)()],p.prototype,"updateSuspended",null),(0,n.Cg)([(0,c.MZ)()],p.prototype,"visible",null),(0,n.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"visibleAtCurrentScale",null),(0,n.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"visibleAtCurrentTimeExtent",null),p=(0,n.Cg)([(0,h.$)("esri.views.layers.LayerView")],p)},96453:(e,t,i)=>{i.d(t,{E:()=>d});var n=i(6326),a=i(50076),r=i(68134),s=i(46053),o=(i(81806),i(76460),i(47249),i(87990)),l=i(65768),c=i(93938),h=i(4225),u=i(90992);const d=e=>{const t=e;let i=class extends t{constructor(){super(...arguments),this.hasMixedImageFormats=!0}get imageFormatIsOpaque(){return!1}get fullExtent(){return this.layer.fullExtent}get isOpaque(){return this.fullOpacity>=1&&this.imageFormatIsOpaque}tilesVisibleAtCurrentScale(){const{minScale:e,maxScale:t}=this.layer;if(!(0,u.WK)(e,t))return!0;const{basemapTerrain:i}=this.view,n=i.getLayerIndexByUID(1,this.uid);if(null==n)return!1;const{tilingScheme:a}=i,r=e&&a.levelAtScale(e),s=t&&a.levelAtScale(t);return i.renderer.visibleTiles.some(e=>!!e.layerInfo[1][n]&&(!r||e.level>=r)&&(!s||e.level<=s))}get visibleAtCurrentScale(){return this.tilesVisibleAtCurrentScale()}get dataScaleRange(){const e=this.tileInfo.lods;let t=e[0].scale,i=e[e.length-1].scale;if("tilemapCache"in this.layer&&this.layer.tilemapCache){const{effectiveMinLOD:e,effectiveMaxLOD:n}=this.layer.tilemapCache;t=this.tileInfo.lodAt(e).scale,i=this.tileInfo.lodAt(n).scale}return{minScale:t,maxScale:i}}canResume(){var e,t,i;const n=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return this.visible&&(null===(e=this.layer)||void 0===e?void 0:e.loaded)&&!(null!==(t=this.parent)&&void 0!==t&&t.suspended)&&(null===(i=this.view)||void 0===i?void 0:i.ready)&&(0,u.g7)(n)&&this.visibleAtCurrentTimeExtent||!1}get dataLevelRange(){const{minScale:e,maxScale:t}=this.dataScaleRange;return this.levelRangeFromScaleRange(e,t)}get displayLevelRange(){const e=this.layer.minScale||this.dataScaleRange.minScale,t=this.layer.maxScale||this.dataScaleRange.maxScale,i=this.levelRangeFromScaleRange(e,t);return this.layer.maxScale&&i.maxLevel++,i}get performanceInfo(){return new l.P(this.view.basemapTerrain.getUsedMemoryForLayerView(this))}getTileUrl(e){return this.layer.getTileUrl(e[0],e[1],e[2])}_addTilingSchemeMatchPromise(){if(null==this.fullExtent)return this.addResolvingPromise(Promise.reject(new a.A("tilingscheme:extent-not-defined","This layer doesn't define a fullExtent.")));const e=this._getTileInfoSupportError(this.tileInfo,this.fullExtent);if(e)return this.addResolvingPromise(Promise.reject(e));this.addResolvingPromise((0,r.C_)(()=>{var e;return null===(e=this.view)||void 0===e||null===(e=e.basemapTerrain)||void 0===e?void 0:e.tilingSchemeLocked}).then(()=>{var e;const t=this.view.basemapTerrain.tilingScheme,i="tilemapCache"in this.layer?null===(e=this.layer.tilemapCache)||void 0===e?void 0:e.effectiveMaxLOD:void 0,n=this._getTileInfoCompatibilityError(this.tileInfo,t,i);if(n)throw n}))}_getTileInfoSupportError(e,t){var i;const n=(0,h._y)(e,t,this.view.spatialReference,this.view.state.viewingMode,"tilemapCache"in this.layer?null===(i=this.layer.tilemapCache)||void 0===i?void 0:i.effectiveMaxLOD:void 0);if(!n)return;const r={layer:this.layer,error:n};switch(n.name){case"tilingscheme:spatial-reference-mismatch":case"tilingscheme:global-unsupported-spatial-reference":case"tilingscheme:local-unsupported-spatial-reference":return new a.A("layerview:spatial-reference-incompatible","The spatial reference of this layer does not meet the requirements of the view",r);default:return new a.A("layerview:tiling-scheme-unsupported","The tiling scheme of this layer is not supported by SceneView",r)}}_getTileInfoCompatibilityError(e,t,i){return null!=e&&t.compatibleWith(e,i)?null:new a.A("layerview:tiling-scheme-incompatible","The tiling scheme of this layer is incompatible with the tiling scheme of the surface")}levelRangeFromScaleRange(e,t){const i={minLevel:0,maxLevel:1/0},n=this.view&&this.view.basemapTerrain&&this.view.basemapTerrain.tilingScheme;if(!n)return i;const a=n.levels[0],r=e=>{const t=Math.log(a.scale/e)/Math.LN2;return.5-Math.abs(.5-t%1)<1e-9?Math.round(t):Math.ceil(t)};return null!=e&&e>0&&(i.minLevel=Math.max(0,r(e))),null!=t&&t>0&&(i.maxLevel=Math.max(0,r(t))),i}isUpdating(){return!!(this.view&&this.view.basemapTerrain&&this.view.basemapTerrain.updating)}};return(0,n.Cg)([(0,s.MZ)({readOnly:!0})],i.prototype,"imageFormatIsOpaque",null),(0,n.Cg)([(0,s.MZ)({readOnly:!0})],i.prototype,"updating",void 0),(0,n.Cg)([(0,s.MZ)(c.S)],i.prototype,"updatingProgress",void 0),(0,n.Cg)([(0,s.MZ)(c.b)],i.prototype,"updatingProgressValue",void 0),(0,n.Cg)([(0,s.MZ)()],i.prototype,"hasMixedImageFormats",void 0),(0,n.Cg)([(0,s.MZ)()],i.prototype,"fullExtent",null),(0,n.Cg)([(0,s.MZ)({readOnly:!0})],i.prototype,"isOpaque",null),(0,n.Cg)([(0,s.MZ)({readOnly:!0})],i.prototype,"visibleAtCurrentScale",null),(0,n.Cg)([(0,s.MZ)()],i.prototype,"dataScaleRange",null),(0,n.Cg)([(0,s.MZ)({readOnly:!0})],i.prototype,"dataLevelRange",null),(0,n.Cg)([(0,s.MZ)({readOnly:!0})],i.prototype,"displayLevelRange",null),(0,n.Cg)([(0,s.MZ)()],i.prototype,"layer",void 0),i=(0,n.Cg)([(0,o.$)("esri.views.3d.layers.TiledLayerView3D")],i),i}}}]);
//# sourceMappingURL=7177.07094ed4.chunk.js.map