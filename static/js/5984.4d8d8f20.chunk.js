"use strict";(self.webpackChunkn2_depot=self.webpackChunkn2_depot||[]).push([[5984],{1734:(e,t,i)=>{i.d(t,{G:()=>b,a:()=>C,b:()=>S});var n,a=i(57528),s=i(72745),r=i(9392),o=i(94192),l=i(83166),c=i(52063),u=i(37754),d=i(95756),h=i(84115),p=i(5517),v=i(21390),f=i(86955),g=i(53908),m=i(72790),_=i(23687),y=i(70571),x=i(31432),w=i(2687);class b extends x.Y{constructor(){super(...arguments),this.totalGaussians=-1,this.focalLength=-1,this.minSplatRadius=-1,this.minSplatOpacity=-1,this.tanFov=s.uY,this.cameraDelta=r.uY,this.cameraPos8k=r.uY}}function S(e){const t=new w.N5;t.varyings.add("vColor","vec4"),t.varyings.add("conicOpacity","vec4"),t.varyings.add("depth","float"),t.varyings.add("gaussianCenterScreenPos","vec2"),t.varyings.add("fragScreenPos","vec2"),t.outputs.add("fragColor","vec4",0),t.vertex.uniforms.add(new y.R("splatOrderTexture",e=>e.splatOrder),new y.R("splatAtlasTexture",e=>e.splatAtlas),new m.c("numSplats",e=>e.totalGaussians),new v.m("focalLength",e=>e.focalLength),new v.m("minSplatRadius",e=>e.minSplatRadius),new v.m("minSplatOpacity",e=>e.minSplatOpacity),new d.G("tanFov",e=>e.tanFov),new p.t("cameraDelta",e=>e.cameraDelta),new p.t("cameraPos8k",e=>e.cameraPos8k),new g.W("fullWidth",e=>{let{camera:t}=e;return t.viewport[2]}),new g.W("fullHeight",e=>{let{camera:t}=e;return t.viewport[3]}),new _.F("proj",e=>e.camera.projectionMatrix),new _.F("view",e=>e.camera.viewMatrix),new h.d("cameraPosition",e=>e.camera.eye)),t.vertex.include(c.e),t.vertex.include(u.J),t.vertex.include(l.T),t.include(o.Z,e),t.vertex.code.add((0,f.H)(n||(n=(0,a.A)(["float ndcToPixel(float ndcCoord, float screenSize) {\nreturn ((ndcCoord + 1.0) * screenSize - 1.0) * 0.5;\n}"])))),t.vertex.main.add("\n    uint instanceID = uint(gl_InstanceID);\n\n    // Transform the instanceID into 2D coordinates\n    uint orderTextureWidth = uint(textureSize(splatOrderTexture, 0).x);\n    uint x = instanceID % orderTextureWidth;\n    uint y = instanceID / orderTextureWidth;\n\n    // Fetch the index of the remaining frontmost Gaussian\n    uint gaussianIndex = texelFetch(splatOrderTexture, ivec2(x, y), 0).r;\n\n    uint splatAtlasSize = uint(textureSize(splatAtlasTexture, 0).x);\n\n    // Fetch the packed Gaussian according to the index\n    uint gaussianIndexX = gaussianIndex % uint(splatAtlasSize);\n    uint gaussianIndexY = gaussianIndex / uint(splatAtlasSize);\n    uvec4 packedGaussian = texelFetch(splatAtlasTexture, ivec2(gaussianIndexX, gaussianIndexY), 0);\n\n    // Fetch the header associated with the packed Gaussian (contains tile origin and number of fractional bits)\n    uint pageNum = gaussianIndex / 1024u;\n    uint headerIndex = (pageNum + 1u) * 1024u - 1u;\n    uint headerIndexX = headerIndex % uint(splatAtlasSize);\n    uint headerIndexY = headerIndex / uint(splatAtlasSize);\n    uvec4 packedHeader = texelFetch(splatAtlasTexture, ivec2(headerIndexX, headerIndexY), 0);\n\n    // Unpack the Gaussian\n    vColor = unpackColor(packedGaussian);\n    // Ignore gaussians with very small contribution, with tolerance based on the quality profile\n    if(vColor.a < minSplatOpacity) {\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      return;\n    }\n\n    vec3 scale = unpackScale(packedGaussian); \n    vec4 quaternion = unpackQuaternion(packedGaussian);\n    mat3 rotation = quaternionToRotationMatrix(quaternion);\n    vec3 tileOriginRelativePosition = unpackTileOriginRelativePosition(packedGaussian);\n\n    vec3 cameraRelativePosition = unpackCameraRelativeGaussianPosition(packedHeader, tileOriginRelativePosition, cameraPosition, cameraPos8k, cameraDelta);\n\n    vec4 viewPos = vec4(mat3(view) * cameraRelativePosition, 1);\n\n    if (viewPos.z > 1.0) {\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      return;\n    }\n\n    forwardViewPosDepth(viewPos.xyz);\n\n    vec3 covarianceA;\n    vec3 covarianceB;\n    computeCovariance3D(rotation, scale.xyz, covarianceA, covarianceB);\n\n    float covariance3D[6] = float[6](covarianceA.x, covarianceA.y, covarianceA.z, covarianceB.x, covarianceB.y, covarianceB.z);\n\n    vec3 covariance2D = computeCovariance2D(viewPos.xyz, focalLength, tanFov, covariance3D, view);\n    \n    // Invert covariance (EWA algorithm)\n    float determinant = (covariance2D.x * covariance2D.z - covariance2D.y * covariance2D.y);\n    if (determinant == 0.) {\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      return;\n    }\n    float invDeterminant = 1. / determinant;\n    \n\n    vec4 projPos = proj * viewPos;\n    float invW = 1. / (projPos.w + 1e-7);\n    vec3 ndcPos = projPos.xyz * invW;\n\n    // Compute extent in screen space (by finding the eigenvalues of the 2D covariance matrix). \n    // Use the extent to compute the bounding rectangle of the Gaussian in screen space.\n    float mid = 0.5 * (covariance2D.x + covariance2D.z);\n    float lambda1 = mid + sqrt(max(0.1, mid * mid - determinant));\n    float lambda2 = mid - sqrt(max(0.1, mid * mid - determinant));\n    float radius = ceil(3. * sqrt(max(lambda1, lambda2)));\n    gaussianCenterScreenPos = vec2(ndcToPixel(ndcPos.x, float(fullWidth)), ndcToPixel(ndcPos.y, float(fullHeight)));\n\n    // Ignore gaussians with very small contribution, with tolerance based on the quality profile\n    if(minSplatRadius > 0.0) {\n      float effectiveSize = radius * vColor.a;\n      if(effectiveSize < minSplatRadius) {\n        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n        return;\n      }\n    }\n\n    // This maps vertex IDs 0, 1, 2, 3 to (-1,-1), (1,-1), (-1,1), (1,1)\n    vec2 corner = vec2((gl_VertexID << 1) & 2, gl_VertexID & 2) - 1.0;\n\n    // Vertex (corner) position in screen space\n    fragScreenPos = gaussianCenterScreenPos + radius * corner;\n\n    // We use a conic function to derive the opacity\n    vec3 conic = vec3(covariance2D.z, -covariance2D.y, covariance2D.x) * invDeterminant;\n    conicOpacity = vec4(conic, vColor.a);\n\n    depth = ndcPos.z;\n    \n    // Convert from screen-space to clip-space\n    vec2 clipPos = fragScreenPos / vec2(fullWidth, fullHeight) * 2. - 1.;\n\n    gl_Position = vec4(clipPos, depth, 1.0);\n\n  ");const i=e.depthPass;return t.fragment.main.add("\n    discardByTerrainDepth();\n    vec2 offsetFromCenter = gaussianCenterScreenPos - fragScreenPos;\n\n    // Evaluate the 2D elliptical Gaussian exponent using the general conic form: Ax^2+2Bxy+Cy^2\n    float x = offsetFromCenter.x;\n    float y = offsetFromCenter.y;\n    float A = conicOpacity.x;\n    float B = conicOpacity.y;\n    float C = conicOpacity.z;\n    float opacityScale = conicOpacity.w;\n    float gaussianExponent = -0.5 * (A * x * x + 2.0 * B * x * y + C * y * y);\n\n    // A positive exponent indicates alpha > 1, this should not happen\n    if (gaussianExponent > 0.0) {\n      discard;\n    }\n\n    float gaussianFalloff = exp(gaussianExponent);\n    \n      // cap at 0.99 to avoid blending issues, such as seams between overlapping Gaussians\n    float alpha = min(.99f, opacityScale * gaussianFalloff);\n\n    // discard low alpha fragments since their contribution would not be visible\n    if (alpha < 1./255.) {\n        discard;\n    }\n\n    // We cannot write color and depth in the same pass, as they require different blend modes.\n    // Regular depth writing based on first hit is not precise enough due to the inherently \n    // transparent nature of Gaussian Splats (especially at the borders of the Splat).\n    // We thus use a blended depth that computes a non-linear average using \n    // the splat order and opacity with geometric decay.\n    // This means the depth is averaged based on the order and opacity of the Gaussians,\n    // with the frontmost Gaussians contributing the most.\n    ".concat((0,f.If)(i,"fragColor = vec4(depth, 0, 0, alpha);","fragColor = vec4(vColor.rgb * alpha, alpha);"),"\n  ")),t}const C=Object.freeze(Object.defineProperty({__proto__:null,GaussianSplatPassParameters:b,build:S},Symbol.toStringTag,{value:"Module"}))},23456:(e,t,i)=>{i.d(t,{_8:()=>m,dJ:()=>g,uB:()=>_});var n=i(89379),a=i(15941),s=i(20664),r=i(9392),o=i(34111),l=i(76797),c=i(91605),u=i(13312),d=i(45308);function h(e,t){if(!Array.isArray(e)||e.length<t)return!1;for(const i of e)if("number"!=typeof i)return!1;return!0}const p=7645211,v={xmin:-180,ymin:-90,zmin:-450,xmax:180,ymax:90,zmax:8850},f=new Map([[5773,new c.A({heightModel:"gravity-related-height",heightUnit:"meters",vertCRS:"EGM96_Geoid"})],[3855,new c.A({heightModel:"gravity-related-height",heightUnit:"meters",vertCRS:"EGM2008_Geoid"})],[115700,new c.A({heightModel:"ellipsoidal",heightUnit:"meters",vertCRS:"WGS_1984"})],[115701,new c.A({heightModel:"ellipsoidal",heightUnit:"meters",vertCRS:"ETRS_1989"})],[6360,new c.A({heightModel:"gravity-related-height",heightUnit:"us-feet",vertCRS:"NAVD88_height_(ftUS)"})],[7837,new c.A({heightModel:"gravity-related-height",heightUnit:"meters",vertCRS:"DHHN2016_(height) "})]]);function g(e){if(!e)return null;const t=e.vcsWkid||e.latestVcsWkid;return t?f.get(t):null}function m(e){var t,i,n,a,s;return!(!(null!==(t=e.extensions)&&void 0!==t&&null!==(t=t.ESRI_crs)&&void 0!==t&&t.wkid||null!==(i=e.extensions)&&void 0!==i&&null!==(i=i.ESRI_crs)&&void 0!==i&&i.latestWkid||null!==(n=e.extensions)&&void 0!==n&&null!==(n=n.ESRI_crs)&&void 0!==n&&n.wkt)||(null===(a=e.root)||void 0===a||null===(a=a.extensions)||void 0===a||null===(a=a.ESRI_crs)||void 0===a||null===(a=a.boundingVolume)||void 0===a||!a.box)&&(null===(s=e.root)||void 0===s||null===(s=s.extensions)||void 0===s||null===(s=s.ESRI_crs)||void 0===s||null===(s=s.boundingVolume)||void 0===s||!s.sphere))}function _(e){var t,i,c,f,g,m,_,y,x,w;let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1],S=new u.A({wkid:4326,vcsWkid:115700}),C=null===(t=e.root)||void 0===t?void 0:t.boundingVolume,A=!1,P=null===e||void 0===e||null===(i=e.root)||void 0===i?void 0:i.transform;if(b&&(null!==(c=e.extensions)&&void 0!==c&&null!==(c=c.ESRI_crs)&&void 0!==c&&c.wkid||null!==(f=e.extensions)&&void 0!==f&&null!==(f=f.ESRI_crs)&&void 0!==f&&f.latestWkid||null!==(g=e.extensions)&&void 0!==g&&null!==(g=g.ESRI_crs)&&void 0!==g&&g.wkt)&&(null!==(m=e.root)&&void 0!==m&&null!==(m=m.extensions)&&void 0!==m&&null!==(m=m.ESRI_crs)&&void 0!==m&&null!==(m=m.boundingVolume)&&void 0!==m&&m.box||null!==(_=e.root)&&void 0!==_&&null!==(_=_.extensions)&&void 0!==_&&null!==(_=_.ESRI_crs)&&void 0!==_&&null!==(_=_.boundingVolume)&&void 0!==_&&_.sphere))S=new u.A(null===(y=e.extensions)||void 0===y?void 0:y.ESRI_crs),C=null===(x=e.root)||void 0===x||null===(x=x.extensions)||void 0===x||null===(x=x.ESRI_crs)||void 0===x?void 0:x.boundingVolume,P=null===(w=e.root)||void 0===w?void 0:w.transform,A=!0;else if(!C)return new l.A(-180,-90,180,90,S);if(C.box){var T;const e=null===(T=C)||void 0===T?void 0:T.box;if(e[3]>p&&e[7]>p&&e[11]>p)return new l.A((0,n.A)((0,n.A)({},v),{},{spatialReference:S}))}const M=(0,r.vt)();if(!A&&C.region&&h(C.region,6)){const e=C.region,t=(0,a.KJ)(e[0]),i=(0,a.KJ)(e[1]),n=e[4],s=(0,a.KJ)(e[2]),r=(0,a.KJ)(e[3]),o=e[5];return new l.A({xmin:t,ymin:i,zmin:n,xmax:s,ymax:r,zmax:o,spatialReference:S})}if(C.sphere&&h(C.sphere,4)){const e=C.sphere,t=(0,r.fA)(e[0],e[1],e[2]),i=e[3]/Math.sqrt(3),n=(0,r.vt)();(0,s.e)(n,t,(0,r.fA)(i,i,i));const a=(0,r.vt)();if((0,s.g)(a,t,(0,r.fA)(i,i,i)),P&&h(P,16)){const e=P;(0,s.t)(M,n,e),(0,s.d)(n,M),(0,s.t)(M,a,e),(0,s.d)(a,M)}A||((0,d.projectBuffer)(n,o.Ro,0,n,u.A.WGS84,0),(0,d.projectBuffer)(a,o.Ro,0,a,u.A.WGS84,0));const c=(0,r.vt)(),p=(0,r.vt)();return(0,s.A)(c,n,a),(0,s.z)(p,n,a),new l.A({xmin:c[0],ymin:c[1],zmin:c[2],xmax:p[0],ymax:p[1],zmax:p[2],spatialReference:S})}if(C.box&&h(C.box,12)){const e=C.box,t=(0,r.fA)(e[0],e[1],e[2]),i=(0,r.fA)(e[3],e[4],e[5]),n=(0,r.fA)(e[6],e[7],e[8]),a=(0,r.fA)(e[9],e[10],e[11]),c=[];for(let s=0;s<8;++s)c.push((0,r.vt)());if((0,s.g)(c[0],t,i),(0,s.g)(c[0],c[0],n),(0,s.g)(c[0],c[0],a),(0,s.a)(c[1],t,i),(0,s.g)(c[1],c[1],n),(0,s.g)(c[1],c[1],a),(0,s.g)(c[2],t,i),(0,s.a)(c[2],c[2],n),(0,s.g)(c[2],c[2],a),(0,s.a)(c[3],t,i),(0,s.a)(c[3],c[3],n),(0,s.g)(c[3],c[3],a),(0,s.g)(c[4],t,i),(0,s.g)(c[4],c[4],n),(0,s.a)(c[4],c[4],a),(0,s.a)(c[5],t,i),(0,s.g)(c[5],c[5],n),(0,s.a)(c[5],c[5],a),(0,s.g)(c[6],t,i),(0,s.a)(c[6],c[6],n),(0,s.a)(c[6],c[6],a),(0,s.a)(c[7],t,i),(0,s.a)(c[7],c[7],n),(0,s.a)(c[7],c[7],a),P&&h(P,16)){const e=P;for(let t=0;t<8;++t)(0,s.t)(c[t],c[t],e)}const p=(0,r.fA)(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),v=(0,r.fA)(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);for(let r=0;r<8;++r)A||(0,d.projectBuffer)(c[r],o.Ro,0,c[r],u.A.WGS84,0),(0,s.A)(v,v,c[r]),(0,s.z)(p,p,c[r]);return new l.A({xmin:v[0],ymin:v[1],zmin:v[2],xmax:p[0],ymax:p[1],zmax:p[2],spatialReference:S})}return new l.A(-180,-90,180,90,S)}},37754:(e,t,i)=>{i.d(t,{J:()=>r});var n,a=i(57528),s=i(86955);function r(e){e.code.add((0,s.H)(n||(n=(0,a.A)(["mat3 quaternionToRotationMatrix(vec4 q) {\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = x2 * q.x;\nfloat yy = y2 * q.y;\nfloat zz = z2 * q.z;\nfloat xy = x2 * q.y;\nfloat xz = x2 * q.z;\nfloat yz = y2 * q.z;\nfloat wx = x2 * q.w;\nfloat wy = y2 * q.w;\nfloat wz = z2 * q.w;\nreturn mat3(\n1.0 - (yy + zz), xy - wz, xz + wy,\nxy + wz, 1.0 - (xx + zz), yz - wx,\nxz - wy, yz + wx, 1.0 - (xx + yy)\n);\n}"]))))}},52063:(e,t,i)=>{i.d(t,{e:()=>u});var n,a,s,r,o,l=i(57528),c=i(86955);function u(e){e.code.add((0,c.H)(n||(n=(0,l.A)(["vec4 unpackColor(uvec4 packedGaussian) {\nvec4 color;\ncolor.r = float((packedGaussian.w >> 1u) & 0xfeu);\ncolor.g = float((packedGaussian.w >> 9u) & 0xffu);\ncolor.b = float((packedGaussian.w >> 16u) & 0xfeu);\ncolor.a = float((packedGaussian.w >> 24u) & 0xffu);\nreturn color / 255.0;\n}"])))),e.code.add((0,c.H)(a||(a=(0,l.A)(["vec3 unpackScale(uvec4 packedGaussian) {\nuint sx = (packedGaussian.z >> 10u) & 0xffu;\nuint sy = (packedGaussian.z >> 18u) & 0xffu;\nuint szLow = (packedGaussian.z >> 26u) & 0x3fu;\nuint szHigh = packedGaussian.a & 0x3u;\nuint sz = szLow | (szHigh << 6u);\nreturn exp(vec3(sx, sy, sz) / 16.0 - 10.0);\n}"])))),e.code.add((0,c.H)(s||(s=(0,l.A)(["const uint MASK_9_BITS = 0x1FFu;\nconst float SQRT_HALF = 0.7071067811865476;\nconst ivec3 COMPONENT_ORDER[4] = ivec3[4](\nivec3(3, 2, 1),\nivec3(3, 2, 0),\nivec3(3, 1, 0),\nivec3(2, 1, 0)\n);\nvec4 unpackQuaternion(uvec4 packedGaussian) {\nuint packedRotation = packedGaussian.x;\nuint largestComponent = packedRotation >> 30u;\nvec4 quaternion = vec4(0.0);\nfloat sumSquares = 0.0;\nuint bitfield = packedRotation;\nfor (int j = 0; j < 3; ++j) {\nint index = COMPONENT_ORDER[int(largestComponent)][j];\nuint magnitude = bitfield & MASK_9_BITS;\nuint signBit = (bitfield >> 9u) & 1u;\nbitfield = bitfield >> 10u;\nfloat value = SQRT_HALF * float(magnitude) / float(MASK_9_BITS);\nquaternion[index] = signBit == 1u ? -value : value;\nsumSquares += value * value;\n}\nquaternion[int(largestComponent)] = sqrt(1.0 - sumSquares);\nreturn quaternion;\n}"])))),e.code.add((0,c.H)(r||(r=(0,l.A)(["vec3 unpackTileOriginRelativePosition(uvec4 packedGaussian) {\nuint packedPositionLow = packedGaussian.y;\nuint packedPositionHigh = packedGaussian.z;\nuint x = packedPositionLow & 0x3FFFu;\nuint y = (packedPositionLow >> 14u) & 0x3FFFu;\nuint zLow = (packedPositionLow >> 28u) & 0xFu;\nuint zHigh = packedPositionHigh & 0x3FFu;\nuint z = zLow | (zHigh << 4u);\nreturn vec3(float(x), float(y), float(z));\n}"])))),e.code.add((0,c.H)(o||(o=(0,l.A)(["vec3 unpackCameraRelativeGaussianPosition(uvec4 packedHeader, highp vec3 position, vec3 cameraPosition, vec3 cameraPos8k, vec3 cameraDelta) {\nvec3 tileOrigin = uintBitsToFloat(packedHeader.xyz);\nfloat invPosScale = 1.0 / exp2(float(packedHeader.w & 0xffu));\nvec3 delta = tileOrigin.xyz - cameraPos8k;\nvec3 cameraRelativePosition = position.xyz * invPosScale + delta * 2.048 - cameraDelta;\nreturn cameraRelativePosition;\n}"]))))}},65984:(e,t,i)=>{i.r(t),i.d(t,{default:()=>ye});var n=i(6326),a=i(76460),s=i(30726),r=i(68134),o=i(31633),l=i(46053),c=(i(81806),i(47249),i(87990)),u=i(4336),d=i(47700),h=i(80963),p=i(23456),v=i(12482),f=i(81478),g=i(65768);class m extends g.P{constructor(e,t,i,n){super(e,0,0,0,t),this.cachedNodes=i,this.memoryMBCached=n}}var _=i(83491),y=i(75228),x=i(59231);const w=4096,b=1023,S=1024;class C{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:64;this._pageCount=e;const t=Math.ceil(e/32);this._bitset=new Uint32Array(t)}get pageCount(){return this._pageCount}isAllocated(e){const t=e/32|0,i=e%32;return!!(this._bitset[t]&1<<i)}allocate(e){const t=e/32|0,i=e%32;this._bitset[t]|=1<<i}free(e){const t=e/32|0,i=e%32;this._bitset[t]&=~(1<<i)}findFirstFreePage(){for(let e=0;e<this._bitset.length;e++)if(4294967295!==this._bitset[e])for(let t=0;t<32;t++){const i=32*e+t;if(i>=this._pageCount)break;if(!(this._bitset[e]&1<<t))return i}return null}resize(e){this._pageCount=e;const t=Math.ceil(e/32),i=this._bitset.length;if(t!==i){const e=new Uint32Array(t),n=Math.min(i,t);e.set(this._bitset.subarray(0,n)),this._bitset=e}this._clearExcessBits(this._bitset,e)}_clearExcessBits(e,t){const i=Math.floor((t-1)/32),n=(t-1)%32;if(t>0&&n<31){const t=(1<<n+1)-1;e[i]&=t}i+1<e.length&&e.fill(0,i+1)}}var A=i(97255);class P{constructor(e,t,i,n,a,s,r){this.handle=e,this.obb=t,this.gaussianAtlasIndices=i,this.pageIds=n,this.positions=a,this.squaredScales=s,this.maxScale=r,this.isVisible=!1,this.usedMemory=(0,A.Qf)(this.gaussianAtlasIndices,this.positions,this.squaredScales)+4096*this.pageIds.length*4}}i(50076);var T=i(19555),M=i(72745),D=i(20664),R=i(9392),z=i(43047),I=i(13927),k=i(95925),G=i(78315),E=i(90364),q=i(45270),O=i(18690),H=i(75540),F=i(1873),U=i(12016);class V extends U.B{constructor(e){super("GaussianSplatSortWorker","sort",{sort:e=>[e.distances.buffer,e.sortOrderIndices.buffer]},e,{strategy:"dedicated"})}sort(e,t){return this.invokeMethod("sort",e,t)}async destroyWorkerAndSelf(){await this.broadcast({},"destroy"),this.destroy()}}i(76718);var B=i(12331),L=(i(44488),i(62881),i(98433)),N=i(93345),W=(i(61678),i(96673));class Z{constructor(e){this.texture=null,this._orderTextureCapacity=0,this._rctx=e}ensureCapacity(e){if(this._orderTextureCapacity<e){var t;null===(t=this.texture)||void 0===t||t.dispose();const i=Math.ceil(e*O.Ji),n=this._evalTextureSize(i),a=n[0]*n[1];this._orderBuffer=new Uint32Array(a);const s=new W.R;s.height=n[0],s.width=n[1],s.pixelFormat=36244,s.dataType=N.ld.UNSIGNED_INT,s.internalFormat=N.H0.R32UI,s.wrapMode=33071,s.samplingMode=9728,this.texture=new L.g(this._rctx,s),this._orderTextureCapacity=a}}setData(e,t){var i,n;this.ensureCapacity(t),null!==(i=this._orderBuffer)&&void 0!==i&&i.set(e),null===(n=this.texture)||void 0===n||n.setData(this._orderBuffer)}clear(){var e;this._orderTextureCapacity=0,null!==(e=this.texture)&&void 0!==e&&e.dispose(),this.texture=null}destroy(){var e;null===(e=this.texture)||void 0===e||e.dispose()}_evalTextureSize(e){const t=Math.ceil(Math.sqrt(e)),i=Math.ceil(e/t);return(0,M.fA)(t,i)}}class j{constructor(e,t,i){this._splatAtlasTextureHeight=16,this.texture=null,this._rctx=e,this._fboCache=i,this.pageAllocator=new C,this._cache=t.newCache("gaussian texture cache",e=>e.dispose())}ensureTextureAtlas(){if(this.texture)return;const e=this._cache.pop("splatTextureAtlas");if(e)return void(this.texture=e);const t=new W.R;t.height=this._splatAtlasTextureHeight,t.width=w,t.pixelFormat=36249,t.dataType=N.ld.UNSIGNED_INT,t.internalFormat=N.H0.RGBA32UI,t.samplingMode=9728,t.wrapMode=33071,this.texture=new L.g(this._rctx,t),this._updatePageAllocator()}grow(){var e,t;if(!this.texture)return this.ensureTextureAtlas(),!1;const i=Math.floor(this._splatAtlasTextureHeight*O.Ji);if(i*w>this._rctx.parameters.maxPreferredTexturePixels)return!1;const n=new B.H(this._rctx,this.texture),a=this._fboCache.acquire(w,i,"gaussian splat atlas resize",11);return this._rctx.blitFramebuffer(n,a.fbo,16384,9728,0,0,w,this._splatAtlasTextureHeight,0,0,w,this._splatAtlasTextureHeight),null!==(e=this.texture)&&void 0!==e&&e.dispose(),this.texture=null===(t=a.fbo)||void 0===t?void 0:t.detachColorTexture(),n.dispose(),a.dispose(),this._splatAtlasTextureHeight=i,this._updatePageAllocator(),!0}requestPage(){let e=this.pageAllocator.findFirstFreePage();return null===e&&this.grow()&&(e=this.pageAllocator.findFirstFreePage()),null!==e&&this.pageAllocator.allocate(e),e}freePage(e){this.pageAllocator.free(e)}update(e,t,i){this.ensureTextureAtlas(),this.texture.updateData(0,e,t,S,1,i)}_updatePageAllocator(){const e=w*this._splatAtlasTextureHeight/S;this.pageAllocator.pageCount!==e&&this.pageAllocator.resize(e)}clear(){this.texture&&(this._cache.put("splatTextureAtlas",this.texture),this.texture=null)}destroy(){var e;this._cache.destroy(),null===(e=this.texture)||void 0===e||e.dispose()}}class J{constructor(e){this._updating=(0,H.v)(!1),this.visibleGaussians=0,this._visibleGaussianTiles=new Array,this._workerHandle=null,this._isSorting=!1,this._pendingSortTask=!1,this._bufferCapacity=0,this._renderer=e,this._orderTexture=new Z(this._renderer.renderingContext),this._textureAtlas=new j(this._renderer.renderingContext,this._renderer.view.resourceController.memoryController,this._renderer.fboCache);const{resourceController:t}=this._renderer.view;this._workerHandle=new V((0,F.m)(t))}get textureAtlas(){return this._textureAtlas}get orderTexture(){return this._orderTexture}get visibleGaussianTiles(){return this._visibleGaussianTiles}updateGaussianVisibility(e){this._visibleGaussianTiles=e,this.requestSort()}isUpdating(){return this._updating.value}destroy(){var e;this._pendingSortTask=!1,null!==(e=this._workerHandle)&&void 0!==e&&e.destroyWorkerAndSelf(),this._textureAtlas.destroy(),this._orderTexture.destroy()}requestSort(){this._updating.value=!0,this._isSorting?this._pendingSortTask=!0:(this._isSorting=!0,this._pendingSortTask=!1,this._sortOnWorker().then(()=>this._handleSortComplete()).catch(()=>this._handleSortComplete()))}_handleSortComplete(){this._isSorting=!1,this._pendingSortTask?this.requestSort():this._updating.value=!1}_clearBuffersAndTextures(){this._bufferCapacity=0,this._orderTexture.clear(),this._textureAtlas.clear()}_ensureBufferCapacity(e){if(this._bufferCapacity<e){const t=Math.ceil(e*O.Ji);this._atlasIndicesBuffer=new Uint32Array(t),this._sortedAtlasIndicesBuffer=new Uint32Array(t),this._distancesBuffer=new Float64Array(t),this._sortOrderBuffer=new Uint32Array(t),this._bufferCapacity=t}}async _sortOnWorker(){var e;let t=0;if(this._visibleGaussianTiles.forEach(e=>t+=e.gaussianAtlasIndices.length),0===t)return this.visibleGaussians=0,this._clearBuffersAndTextures(),void this._renderer.requestRender(1);this._ensureBufferCapacity(t),this._textureAtlas.ensureTextureAtlas();const i=this._renderer.camera.eye,n=i[0],a=i[1],s=i[2],r=this._atlasIndicesBuffer.subarray(0,t);let o=0;this._visibleGaussianTiles.forEach(e=>{const t=e.gaussianAtlasIndices,i=e.positions;for(let l=0;l<t.length;l++){r[o]=t[l];const e=3*l,c=i[e],u=i[e+1],d=i[e+2],h=c-n,p=u-a,v=d-s;this._distancesBuffer[o]=h*h+p*p+v*v,o++}});for(let c=0;c<t;c++)this._sortOrderBuffer[c]=c;const l={distances:this._distancesBuffer,sortOrderIndices:this._sortOrderBuffer,numGaussians:t,preciseSort:!1};await(null===(e=this._workerHandle)||void 0===e?void 0:e.sort(l).then(e=>{this._distancesBuffer=e.distances,this._sortOrderBuffer=e.sortedOrderIndices;const i=this._sortedAtlasIndicesBuffer.subarray(0,t);for(let a=0;a<t;a++)i[a]=r[e.sortedOrderIndices[a]];this._orderTexture.setData(i,t);const n=this._renderer.view.qualitySettings.gaussianSplat.maxAllowedVisibleGaussians;this.visibleGaussians=Math.min(t,n),this._renderer.requestRender(1)}))}}var Y=i(36451),X=i(82805),$=i(1734),K=i(87986),Q=i(16506),ee=i(59246),te=i(11850),ie=i(57162);class ne extends ee.w{constructor(e,t){super(e,t,new Q.$(K.S,()=>i.e(8392).then(i.bind(i,48392))),te.Nx)}initializePipeline(){return(0,ie.Ey)({colorWrite:ie.kn,depthTest:null,depthWrite:ie.Uy})}}var ae=i(95745);class se extends ee.w{constructor(e,t){super(e,t,new Q.$(ae.S,()=>i.e(6691).then(i.bind(i,16691))),te.Nx)}initializePipeline(){return(0,ie.Ey)({colorWrite:null,depthTest:{func:515},depthWrite:ie.Uy,drawBuffers:{buffers:[N.$0]}})}}class re extends ee.w{constructor(e,t){super(e,t,new Q.$($.a,()=>i.e(2416).then(i.bind(i,82416))),te.Nx)}_createPipeline(){return(0,ie.Ey)({blending:(0,ie.p3)(773,773,772,1,32774,32774),depthTest:{func:513},colorWrite:ie.kn})}initializePipeline(){return this._createPipeline()}}class oe extends ee.w{constructor(e,t){super(e,t,new Q.$($.a,()=>i.e(2416).then(i.bind(i,82416))),te.Nx)}_createPipeline(){return(0,ie.Ey)({blending:(0,ie.p3)(773,773,1,1,32774,32774),depthTest:{func:515},colorWrite:ie.kn})}initializePipeline(){return this._createPipeline()}}var le,ce,ue=i(6485);class de extends ue.K{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];super(),this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.occlusionPass=!1,this.depthPass=e}}(0,n.Cg)([(0,ue.W)()],de.prototype,"terrainDepthTest",void 0),(0,n.Cg)([(0,ue.W)()],de.prototype,"cullAboveTerrain",void 0);let he=(le=class extends Y.A{constructor(){super(...arguments),this.gaussianPosition=(0,R.vt)(),this.intersectionRayDir=(0,R.vt)(),this.intersectionPlane=(0,I.vt)(),this._slicePlaneEnabled=!1,this._data=null,this.produces=E.hM.OPAQUE,this.type=0,this.isGround=!1,this.layerViewUid="",this._gaussianSplatParameters=new $.G,this._gaussianSplatCompositionParameters=new K.G,this._gaussianSplatDepthCompositionParameters=new ae.G,this._splatTechniqueConfiguration=new de,this._splatDepthTechniqueConfiguration=new de(!0),this._previousCameraPosition=(0,R.vt)(),this._previousCameraDirection=(0,R.vt)(),this._tanFov=(0,M.vt)(),this._tempVec=(0,R.vt)(),this._cameraDelta=(0,R.vt)(),this._coarseCameraPosition=(0,R.vt)()}async initialize(){this._data=new J(this),this.view.sceneIntersectionHelper.addIntersectionHandler(this),this.addHandles([(0,r.wB)(()=>this.view.state.camera,()=>this._onCameraChange())])}precompile(){this._splatTechniqueConfiguration.terrainDepthTest=this.bindParameters.terrainDepthTest,this.techniques.precompile(oe,this._splatTechniqueConfiguration),this._splatDepthTechniqueConfiguration.terrainDepthTest=this.bindParameters.terrainDepthTest,this.techniques.precompile(re,this._splatDepthTechniqueConfiguration),this.techniques.precompile(ne),this.techniques.precompile(se)}render(e){const t=e.find(e=>{let{name:t}=e;return t===E.hM.OPAQUE});if(!this._data.visibleGaussians||!this._data.orderTexture.texture||!this._data.textureAtlas.texture)return t;const i=this.techniques.get(oe,this._splatTechniqueConfiguration),n=this.techniques.get(re,this._splatDepthTechniqueConfiguration),a=this.techniques.get(ne),s=this.techniques.get(se);if(!(i.compiled&&n.compiled&&s.compiled&&a.compiled))return this.requestRender(1),t;const{fullWidth:r,fullHeight:o}=this.bindParameters.camera,l=this.fboCache,c=l.acquire(r,o,"gaussian color output");c.attachDepth(t.getAttachment(N.nI));const u=this.renderingContext;u.bindFramebuffer(c.fbo),u.setClearColor(0,0,0,0),u.clear(16384),this._gaussianSplatParameters.totalGaussians=this._data.visibleGaussians,this._gaussianSplatParameters.splatOrder=this._data.orderTexture.texture,this._gaussianSplatParameters.splatAtlas=this._data.textureAtlas.texture;const d=Math.tan(.5*this.camera.fovY),h=d/o*r;(0,T.hZ)(this._tanFov,h,d);const p=o/(2*d);this._gaussianSplatParameters.focalLength=p,this._gaussianSplatParameters.tanFov=this._tanFov;const v=this.view.qualitySettings.gaussianSplat,f=v.minimumSplatPixelRadius*Math.sqrt(r*o)/Math.sqrt(2073600);this._gaussianSplatParameters.minSplatRadius=f,this._gaussianSplatParameters.minSplatOpacity=v.minimumOpacity,this._prepareHighPrecisionCameraPosition(),this.renderingContext.bindTechnique(i,this.bindParameters,this._gaussianSplatParameters),this.renderingContext.drawArraysInstanced(N.WR.TRIANGLE_STRIP,0,4,this._data.visibleGaussians);const g=l.acquire(r,o,"splat depth",8);g.attachDepth(t.getAttachment(N.nI)),u.bindFramebuffer(g.fbo),u.setClearColor(0,0,0,0),u.clear(16384),this.renderingContext.bindTechnique(n,this.bindParameters,this._gaussianSplatParameters),this.renderingContext.drawArraysInstanced(N.WR.TRIANGLE_STRIP,0,4,this._data.visibleGaussians);const m=l.acquire(r,o,this.produces);return this._gaussianSplatDepthCompositionParameters.splatDepth=g.getTexture(),m.attachDepth(t.getAttachment(N.nI)),u.bindFramebuffer(m.fbo),u.bindTechnique(s,this.bindParameters,this._gaussianSplatDepthCompositionParameters),u.screen.draw(),this._gaussianSplatCompositionParameters.color=t.getTexture(),this._gaussianSplatCompositionParameters.splatColor=c.getTexture(),u.bindFramebuffer(m.fbo),u.bindTechnique(a,this.bindParameters,this._gaussianSplatCompositionParameters),u.screen.draw(),c.release(),g.release(),m}intersect(e,t,i,n){const{gaussianPosition:a,intersectionRayDir:s,intersectionPlane:r,layerViewUid:o}=this,l=(0,k.Cr)(i,n);(0,D.e)(s,n,i);const c=1/(0,D.b)(s);(0,D.h)(s,s,c);const u=(0,R.vt)();(0,D.u)(u,s),(0,z.s)(r,s[0],s[1],s[2],-(0,D.f)(s,i));const d=new ve,h=new ve,p=new Array;this._data.visibleGaussianTiles.forEach(v=>{const{maxScale:f}=v,g=v.obb.minimumDistancePlane(r),m=v.obb.maximumDistancePlane(r),_=m<0,y=null!=d.dist&&null!=h.dist&&d.dist<g*c&&h.dist>m*c;if(_||y)return;const x=(0,G.j)(v.obb.center,v.obb.radius+f);if(!(0,G.i)(x,l,null))return;if(!v.obb.intersectRay(i,s,f))return;const{positions:w,squaredScales:b,gaussianAtlasIndices:S}=v,C=S.length;for(let r=0;r<C;r++){const l=3*r;a[0]=w[l]-i[0],a[1]=w[l+1]-i[1],a[2]=w[l+2]-i[2];const v=b[r],f=(0,D.f)(a,s),g=f*f;if((0,D.m)(a)-g>v)continue;const m=f*c,_=e=>(e.point=e.point?e.point.fill(a[0],a[1],a[2]):(0,R.o8)(a),e.dist=m,e.normal=u,e.layerViewUid=o,e);if((null==d.dist||m<d.dist)&&(null==t||t(i,n,m))&&_(d),0!==e.options.store&&(null==h.dist||m>h.dist)&&(null==t||t(i,n,m))&&_(h),2===e.options.store&&(null==t||t(i,n,m))){const e=new ve;p.push(_(e))}}});const v=(e,t)=>{const{layerViewUid:i}=t,n=new q.bo(t.point,i);e.set(0,n,t.dist,t.normal)};if(pe(d)){const t=e.results.min;(null==t.distance||d.dist<t.distance)&&v(t,d)}if(pe(h)&&0!==e.options.store){const t=e.results.max;(null==t.distance||h.dist>t.distance)&&v(t,h)}if(2===e.options.store)for(const f of p){const t=new X.i(l);v(t,f),e.results.all.push(t)}}get slicePlaneEnabled(){return this._slicePlaneEnabled}set slicePlaneEnabled(e){this._slicePlaneEnabled!==e&&(this._slicePlaneEnabled=e,this.requestRender(1))}get data(){return this._data}destroy(){this._data.destroy(),super.destroy()}_onCameraChange(){const e=this.view.state.camera.eye,t=this.view.state.camera.ray.direction,i=.001;(Math.abs(e[0]-this._previousCameraPosition[0])>i||Math.abs(e[1]-this._previousCameraPosition[1])>i||Math.abs(e[2]-this._previousCameraPosition[2])>i||Math.abs(t[0]-this._previousCameraDirection[0])>i||Math.abs(t[1]-this._previousCameraDirection[1])>i||Math.abs(t[2]-this._previousCameraDirection[2])>i)&&this._data.requestSort()}_prepareHighPrecisionCameraPosition(){(0,D.h)(this._tempVec,this.camera.eye,1/ce.tileSize),(0,D.J)(this._tempVec,this._tempVec),(0,D.d)(this._coarseCameraPosition,this._tempVec),this._gaussianSplatParameters.cameraPos8k=this._coarseCameraPosition,(0,D.h)(this._tempVec,this._tempVec,ce.tileSize),(0,D.e)(this._cameraDelta,this.camera.eye,this._tempVec),this._gaussianSplatParameters.cameraDelta=this._cameraDelta}},ce=le,le.tileSize=2.048,le);function pe(e){return null!=e.dist&&null!=e.point}he=ce=(0,n.Cg)([(0,c.$)("esri.views.3d.webgl-engine.lib.GaussianSplatRenderNode")],he);class ve{constructor(){this.point=null,this.dist=null,this.normal=null,this.layerViewUid=""}}var fe=i(91196),ge=i(90992);const me=()=>a.A.getLogger("esri.views.3d.layers.GaussianSPlatLayerView3D");let _e=class extends((0,_.w)(fe.A)){constructor(e){super(e),this.type="gaussian-splat-3d",this._gaussianTileHandles=new Map,this._pageBuffer=new Uint32Array(4096),this._wasmLayerId=-1,this._metersPerVCSUnit=1,this.ignoresMemoryFactor=!1,this._usedMemory=0,this._cacheMemory=0,this._useEsriCrs=!1,this.fullExtentInLocalViewSpatialReference=null,this._suspendedHandle=null,this._conversionBuffer=new ArrayBuffer(4),this._u32View=new Uint32Array(this._conversionBuffer),this._f32View=new Float32Array(this._conversionBuffer);const{view:t}=e;this._memCache=t.resourceController.memoryController.newCache("GaussianSplat-".concat(this.uid),e=>this._deleteTile(e)),this._renderNode=new he({view:t})}initialize(){var e;if(!this._canProjectWithoutEngine())throw(0,ge.lQ)("layer",this.layer.spatialReference.wkid,null===(e=this.view.renderSpatialReference)||void 0===e?void 0:e.wkid);const t=(0,y.Bk)(this).then(e=>{this._wasmLayerId=e,this.addHandles([(0,r.wB)(()=>this.layer.elevationInfo,e=>this._elevationInfoChanged(e))]),this._suspendedHandle=(0,r.wB)(()=>this.suspended,e=>{var t;return null===(t=this._wasm)||void 0===t?void 0:t.setEnabled(this,!e)},r.pc)});this.addResolvingPromise(t)}get wasmLayerId(){return this._wasmLayerId}get metersPerVCSUnit(){return this._metersPerVCSUnit}isUpdating(){const e=this._wasm;return!(this._wasmLayerId<0||null==e)&&(e.isUpdating(this._wasmLayerId)||this._renderNode.data.isUpdating())}updatingFlagChanged(){this.notifyChange("updating")}get _wasm(){return(0,y.pw)(this.view)}get usedMemory(){return this._usedMemory}get unloadedMemory(){return 0}get cachedMemory(){return this._cacheMemory}get useEsriCrs(){return this._useEsriCrs}async createRenderable(e){const t=e.meshData;if(null==t.data)throw new Error("meshData.data undefined");if(t.desc=JSON.parse(t.desc),null==t.desc)throw new Error("meshData.desc undefined");const i=t.desc.prims[0],n=i.vertexCount,a=i.atrbs[0].view,s=i.atrbs[0].view.byteCount,r=i.atrbs[0].view.byteOffset;let o=null;if("U32"!==a.type)return me().warnOnce("unexpected meshData.data format"),{memUsageBytes:0};o=new Uint32Array(t.data.buffer,r,s/4);const l=this.extractHeader(o),c=Math.ceil(n/b),d=new Uint32Array(n),h=[];for(let u=0;u<c;u++){let e=this._data.textureAtlas.requestPage();if(null===e&&(this._freeInvisibleTiles(),e=this._data.textureAtlas.requestPage()),null===e)return me().warnOnce("ran out of gaussian splat memory"),{memUsageBytes:0};{h.push(e);const t=n-u*b,i=Math.min(t,b),a=u*b;for(let n=0;n<i;n++)d[n+a]=n+S*e;const s=4092*u;this._pageBuffer.set(o.subarray(s,s+4*i)),this._pageBuffer.set(l.packedHeader,4092);const r=e*S,c=r%w,p=Math.floor(r/w);this._data.textureAtlas.update(c,p,this._pageBuffer)}}const p=new Float64Array(3*n),v=new Float64Array(n),f=2.048,g=l.tileOrigin.x*f,m=l.tileOrigin.y*f,_=l.tileOrigin.z*f,y=l.invPosScale;let C=0,A=0;for(let u=0;u<n;u++){const e=4*u,{rawX:t,rawY:i,rawZ:n}=this._extractGaussianPosition(o,e),a=this._extractGaussianSphericalScale(o,e);p[C]=t*y+g,p[C+1]=i*y+m,p[C+2]=n*y+_,v[u]=a*a,A=Math.max(A,a),C+=3}let T=null;if(t.desc.obb){const e=t.desc.obb.quaternion;T=new x.ab(t.desc.obb.center,t.desc.obb.halfSize,(0,u.fA)(...e))}T||(me().warnOnce("encountered tile without a bounding box"),T=new x.ab);const M=new P(e.handle,T,d,h,p,v,A);return this._memCache.put("".concat(M.handle),M),this._gaussianTileHandles.set(e.handle,M),this._cacheMemory+=M.usedMemory,{memUsageBytes:M.usedMemory}}_extractGaussianPosition(e,t){const i=e[t+1];return{rawX:16383&i,rawY:i>>>14&16383,rawZ:i>>>28&15|(1023&e[t+2])<<4}}_extractGaussianSphericalScale(e,t){const i=e[t+2],n=i>>>10&255,a=i>>>18&255,s=i>>>26&63|(3&e[t+3])<<6,r=Math.exp(n/16-10),o=Math.exp(a/16-10),l=Math.exp(s/16-10);return Math.max(r,o,l)}freeRenderable(e){const t=this._gaussianTileHandles.get(e);t&&(t.isVisible?this._usedMemory-=t.usedMemory:this._cacheMemory-=t.usedMemory,t.pageIds.forEach(e=>this._data.textureAtlas.freePage(e)),this.freeObject(t),this._gaussianTileHandles.delete(e)),this._updateGaussians()}freeObject(e){this._memCache.pop("".concat(e.handle))}get visibleAtCurrentScale(){return(0,ge.E5)(this.layer.effectiveScaleRange,this.view.scale)}setRenderableVisibility(e,t,i){for(let n=0;n<i;n++){if(!t[n])continue;const i=e[n],a=this._gaussianTileHandles.get(i);if(a){if(a.isVisible)continue;a.isVisible=!0,this._usedMemory+=a.usedMemory,this._cacheMemory-=a.usedMemory,this._memCache.pop("".concat(i))}}for(let n=0;n<i;n++){if(t[n])continue;const i=e[n],a=this._gaussianTileHandles.get(i);if(a){if(!a.isVisible)continue;a.isVisible=!1,this._usedMemory-=a.usedMemory,this._cacheMemory+=a.usedMemory,this._memCache.put("".concat(i),a)}}this._updateGaussians()}destroy(){(0,y.r8)(this),this._suspendedHandle&&(this._suspendedHandle=(0,s.xt)(this._suspendedHandle)),this._renderNode.destroy(),this._memCache.destroy()}_canProjectWithoutEngine(){if(1===this.view.state.viewingMode)return!0;if((0,h.r1)(this.view.renderSpatialReference)||(0,h.K8)(this.view.renderSpatialReference))return!0;if(this.layer.esriCrsSpatialReference&&(0,h.aI)(this.layer.esriCrsSpatialReference,this.view.renderSpatialReference)){const e=(0,p.dJ)(this.layer.esriCrsSpatialReference),t=this.view.heightModelInfo;return this._useEsriCrs=0===(0,d.$U)(e,t,!1),this._useEsriCrs&&e&&(this._metersPerVCSUnit=(0,o.oU)(1,"meters",e.heightUnit),this.fullExtentInLocalViewSpatialReference=this.layer.esriCrsFullExtent),this._useEsriCrs}return!1}_elevationInfoChanged(e){var t,i;if(null!==e&&void 0!==e&&e.offset)if(this._useEsriCrs){var n,a;const t=(0,f.Ao)(null===e||void 0===e?void 0:e.unit)/this._metersPerVCSUnit,i=null!==(n=null===e||void 0===e?void 0:e.offset)&&void 0!==n?n:0;null===(a=this._wasm)||void 0===a||a.setLayerOffset(this,i*t)}else null===(t=this._wasm)||void 0===t||t.setLayerOffset(this,(0,v.M7)(e));else null===(i=this._wasm)||void 0===i||i.setLayerOffset(this,0)}_updateGaussians(){const e=new Array;for(const t of this._gaussianTileHandles.values())t.isVisible&&e.push(t);this._data.updateGaussianVisibility(e),this.notifyChange("updating")}_freeInvisibleTiles(){for(const e of this._gaussianTileHandles.values())e.isVisible||this._deleteTile(e)}get _data(){return this._renderNode.data}extractHeader(e){const t=e.length-4,i=this.reinterpretU32AsFloat(e[t]),n=this.reinterpretU32AsFloat(e[t+1]),a=this.reinterpretU32AsFloat(e[t+2]),s=1/(1<<(255&e[t+3]));return{packedHeader:e.subarray(t,t+4),tileOrigin:{x:i,y:n,z:a},invPosScale:s}}_deleteTile(e){var t;null!==(t=this._wasm)&&void 0!==t&&t.onRenderableEvicted(this,e.handle,e.usedMemory),this.freeRenderable(e.handle)}reinterpretU32AsFloat(e){return this._u32View[0]=e,this._f32View[0]}get performanceInfo(){let e=0,t=0;return this._gaussianTileHandles.forEach(i=>{i.isVisible?e++:t++}),new m(this.usedMemory,e,t,this.cachedMemory)}};(0,n.Cg)([(0,l.MZ)()],_e.prototype,"layer",void 0),(0,n.Cg)([(0,l.MZ)()],_e.prototype,"fullExtentInLocalViewSpatialReference",void 0),(0,n.Cg)([(0,l.MZ)({readOnly:!0})],_e.prototype,"visibleAtCurrentScale",null),_e=(0,n.Cg)([(0,c.$)("esri.views.3d.layers.GaussianSplatLayerView3D")],_e);const ye=_e},83166:(e,t,i)=>{i.d(t,{T:()=>r});var n,a=i(57528),s=i(86955);function r(e){e.code.add((0,s.H)(n||(n=(0,a.A)(["void computeCovariance3D(in mat3 rotation, in vec3 scale, out vec3 covarianceA, out vec3 covarianceB) {\nmat3 scaleMatrix = mat3(\nvec3(scale.x, 0.0, 0.0),\nvec3(0.0, scale.y, 0.0),\nvec3(0.0, 0.0, scale.z)\n);\nmat3 M = scaleMatrix * rotation;\nmat3 covariance3D = transpose(M) * M;\ncovarianceA = vec3(covariance3D[0][0], covariance3D[0][1], covariance3D[0][2]);\ncovarianceB = vec3(covariance3D[1][1], covariance3D[1][2], covariance3D[2][2]);\n}\nvec3 computeCovariance2D(vec3 center, float focalLength, vec2 tanFov, float[6] cov3D, mat4 view) {\nvec4 viewSpacePoint = vec4(center, 1);\nvec2 max = 1.3 * tanFov;\nvec2 normalized = viewSpacePoint.xy / viewSpacePoint.z;\nviewSpacePoint.xy = clamp(normalized, -max, max) * viewSpacePoint.z;\nfloat invZ = 1.0 / viewSpacePoint.z;\nfloat invZSquared = invZ * invZ;\nmat3 projectionJacobian = mat3(\nfocalLength * invZ,  0.0,                   -(focalLength * viewSpacePoint.x) * invZSquared,\n0.0,                 focalLength * invZ,    -(focalLength * viewSpacePoint.y) * invZSquared,\n0.0,                 0.0,                   0.0\n);\nmat3 worldToView = transpose(mat3(view));\nmat3 T = worldToView * projectionJacobian;\nmat3 covariance3D = mat3(\ncov3D[0], cov3D[1], cov3D[2],\ncov3D[1], cov3D[3], cov3D[4],\ncov3D[2], cov3D[4], cov3D[5]\n);\nmat3 covariance2D = transpose(T) * transpose(covariance3D) * T;\nconst float regularization = 0.3;\ncovariance2D[0][0] += regularization;\ncovariance2D[1][1] += regularization;\nreturn vec3(covariance2D[0][0], covariance2D[0][1], covariance2D[1][1]);\n}"]))))}},83491:(e,t,i)=>{i.d(t,{w:()=>u});var n=i(6326),a=i(54901),s=i(50346),r=i(68134),o=i(46053),l=(i(81806),i(76460),i(47249),i(87990)),c=i(47700);const u=e=>{const t=e;let i=class extends t{constructor(){super(...arguments),this.slicePlaneEnabled=!1,this.supportsHeightUnitConversion=!1}postscript(){super.postscript(),(0,c.jI)(this.layer)&&this.addResolvingPromise(this._validateHeightModelInfo())}async _validateHeightModelInfo(){const e=new AbortController,t=e.signal;this.addHandles((0,a.hA)(()=>e.abort())),await(0,r.C_)(()=>{var e;return null===(e=this.view.defaultsFromMap)||void 0===e?void 0:e.heightModelInfoReady},t),(0,s.Te)(t);const i=(0,c.Hu)(this.layer,this.view.heightModelInfo,this.supportsHeightUnitConversion);if(i)throw i}};return(0,n.Cg)([(0,o.MZ)()],i.prototype,"view",void 0),(0,n.Cg)([(0,o.MZ)()],i.prototype,"slicePlaneEnabled",void 0),i=(0,n.Cg)([(0,l.$)("esri.views.3d.layers.LayerView3D")],i),i}},87986:(e,t,i)=>{i.d(t,{G:()=>u,S:()=>h,b:()=>d});var n,a=i(57528),s=i(73398),r=i(86955),o=i(70367),l=i(31432),c=i(2687);class u extends l.Y{}function d(){const e=new c.N5;return e.include(s.c),e.fragment.uniforms.add(new o.N("colorTexture",e=>e.color),new o.N("splatOutputColor",e=>e.splatColor)),e.fragment.main.add((0,r.H)(n||(n=(0,a.A)(["vec4 color = texture(colorTexture, uv);\nvec4 splatColor = texture(splatOutputColor, uv);\nfragColor = splatColor + color * (1.0 - splatColor.a);"])))),e}const h=Object.freeze(Object.defineProperty({__proto__:null,GaussianSplatCompositionPassParameters:u,build:d},Symbol.toStringTag,{value:"Module"}))},91196:(e,t,i)=>{i.d(t,{A:()=>p});var n=i(6326),a=i(54099),s=i(5632),r=i(76460),o=i(30726),l=i(91291),c=i(46053),u=(i(81806),i(47249),i(87990)),d=i(19451),h=i(90992);let p=class extends((0,s.sA)((0,l.g)(a.nJ))){get spatialReferenceSupported(){return!0}constructor(e){super(e),this._updatingHandles=new d.U,this.layer=null,this.parent=null}initialize(){this.when().catch(e=>{if("layerview:create-error"!==e.name){var t;const i=this.layer&&this.layer.id||"no id",n=(null===(t=this.layer)||void 0===t?void 0:t.title)||"no title";r.A.getLogger(this).error("#resolve()","Failed to resolve layer view (layer title: '".concat(n,"', id: '").concat(i,"')"),e)}})}destroy(){this._updatingHandles=(0,o.pR)(this._updatingHandles),this._set("parent",null)}get fullOpacity(){var e,t,i,n;return(null!==(e=null===(t=this.layer)||void 0===t?void 0:t.opacity)&&void 0!==e?e:1)*(null!==(i=null===(n=this.parent)||void 0===n?void 0:n.fullOpacity)&&void 0!==i?i:1)}get suspended(){return this.destroyed||!this.canResume()}get suspendInfo(){return this.getSuspendInfo()}get legendEnabled(){var e;return!this.suspended&&!0===(null===(e=this.layer)||void 0===e?void 0:e.legendEnabled)}get updating(){var e;return!((null===(e=this._updatingHandles)||void 0===e||!e.updating)&&!this.isUpdating())}get updatingProgress(){return this.updating?0:1}get updateSuspended(){return this.suspended}get visible(){var e;return!0===(null===(e=this.layer)||void 0===e?void 0:e.visible)}set visible(e){this._overrideIfSome("visible",e)}get visibleAtCurrentScale(){return!0}get visibleAtCurrentTimeExtent(){var e;const t=this.view.timeExtent,i=null===(e=this.layer)||void 0===e?void 0:e.visibilityTimeExtent;return!t||!i||!t.intersection(i).isEmpty}canResume(){var e,t;const i=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return this.visible&&(null===(e=this.layer)||void 0===e?void 0:e.loaded)&&this.parent&&!this.parent.suspended&&(null===(t=this.view)||void 0===t?void 0:t.ready)&&(0,h.g7)(i)&&this.visibleAtCurrentScale&&this.visibleAtCurrentTimeExtent||!1}getSuspendInfo(){var e,t;const i=null!==(e=this.parent)&&void 0!==e&&e.suspended?this.parent.suspendInfo:{};null!==(t=this.view)&&void 0!==t&&t.ready||(i.viewNotReady=!0),this.layer&&this.layer.loaded||(i.layerNotLoaded=!0);const n=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return(0,h.g7)(n)&&this.visibleAtCurrentScale||(i.outsideScaleRange=!0),this.visibleAtCurrentTimeExtent||(i.outsideVisibilityTimeExtent=!0),this.visible||(i.layerInvisible=!0),i}isUpdating(){return!1}};(0,n.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"spatialReferenceSupported",null),(0,n.Cg)([(0,c.MZ)()],p.prototype,"view",void 0),(0,n.Cg)([(0,c.MZ)()],p.prototype,"fullOpacity",null),(0,n.Cg)([(0,c.MZ)()],p.prototype,"layer",void 0),(0,n.Cg)([(0,c.MZ)()],p.prototype,"parent",void 0),(0,n.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"suspended",null),(0,n.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"suspendInfo",null),(0,n.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"legendEnabled",null),(0,n.Cg)([(0,c.MZ)({type:Boolean,readOnly:!0})],p.prototype,"updating",null),(0,n.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"updatingProgress",null),(0,n.Cg)([(0,c.MZ)()],p.prototype,"updateSuspended",null),(0,n.Cg)([(0,c.MZ)()],p.prototype,"visible",null),(0,n.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"visibleAtCurrentScale",null),(0,n.Cg)([(0,c.MZ)({readOnly:!0})],p.prototype,"visibleAtCurrentTimeExtent",null),p=(0,n.Cg)([(0,u.$)("esri.views.layers.LayerView")],p)},95745:(e,t,i)=>{i.d(t,{G:()=>u,S:()=>h,b:()=>d});var n,a=i(57528),s=i(73398),r=i(86955),o=i(70367),l=i(31432),c=i(2687);class u extends l.Y{}function d(){const e=new c.N5;return e.include(s.c),e.fragment.uniforms.add(new o.N("splatOutputDepth",e=>e.splatDepth)),e.fragment.main.add((0,r.H)(n||(n=(0,a.A)(["vec4 splatDepth = texture(splatOutputDepth, uv);\nfloat ndcDepth = splatDepth.x;\nfloat depthCutOff = 0.75;\nif(splatDepth.a < depthCutOff) {\ndiscard;\n}\ngl_FragDepth = (ndcDepth + 1.0) * 0.5;"])))),e}const h=Object.freeze(Object.defineProperty({__proto__:null,GaussianSplatDepthCompositionPassParameters:u,build:d},Symbol.toStringTag,{value:"Module"}))}}]);
//# sourceMappingURL=5984.4d8d8f20.chunk.js.map